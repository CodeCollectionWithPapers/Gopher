input_format_example1=
"""
public static boolean equal(GeneralPath p1, GeneralPath p2) {
        if (p1 == null) {
            return (p2 == null);
        }
        if (p2 == null) {
            return false;
        }
        PathIterator iterator1 = p1.getPathIterator(null);
        PathIterator iterator2 = p1.getPathIterator(null);
        return true;
    }
"""

output_format_example1=
"""
public static boolean equal(GeneralPath p1, GeneralPath p2) {
        if (p1 == null) {
            return (p2 == null);
        }
        if (p2 == null) {
            return false;
        }
       PathIterator iterator1 = p1.getPathIterator(null);
       PathIterator iterator2 = p2.getPathIterator(null);
       return true;
    }
"""

input_format_example2=
"""
 int  binarySearch(int arr[], int size, int target) { 
       int left = 0;
       int right = size - 1;

       while (left < right) {
        ……
        }
       return -1;
}
"""
output_format_example2=
"""
Action: replace
Location: 5
Patch: while (left <= right) {
"""

standard_repair_prompt: |
  {{ module_1_preamble }}
  
  {{ module_2_buggy_artifact }}
  
  {{ module_3_context }}
  
  {{ module_4_feedback }}
  
  {{ module_5_postamble }}

modules:
  preamble:
    system_message: |
      You are a professional program analysis and repair assistant specializing in bug diagnosis.
      Your objective is to repair the bugs in the method. 


    user_instruction: |
      Your task is to generate a patch and indicate the repair action (i.e., add, replace, swap, or delete) and its corresponding location for the bug based on the information provided below. 
      The given buggy method and the buggy location are [buggy method] and [buggy line]. The essential context of the bug is provided in [bug-dependent context]. 
      Failure test messages or commit messages associated with the bug are included in [bug test information]. 
      Please note that your generated patch should strictly comply with the [output format].


  buggy_artifact: |
    ### 1. Buggy Method
    File: {{ file_path }}
    Method Name: {{ method_name }}
    
    ```{{ language }}
    {{ buggy_method_body }}
    ```

  context:
    none: |
      ### 2. Context Information
      (No additional context provided for this iteration.)

    slice: |
      ### 2. Focused Dependency Slices
      The following code slices are extracted based on Data Dependencies and Control Dependencies related to the bug.
      Use this to understand variable flows and logic conditions influencing the bug.
      
      #### Data Dependency Slice:
      ```{{ language }}
      {{ data_dependency_slice }}
      ```
      
      #### Control Dependency Slice:
      ```{{ language }}
      {{ control_dependency_slice }}
      ```

    periphery: |
      ### 2. Peripheral Class Context
      The following is the class skeleton surrounding the buggy method. 
      It includes import statements, class member declarations, and other method signatures.
      Use this to identify correct variable types, available helper methods, and imports.
      
      ```{{ language }}
      {{ class_skeleton }}
      ```

  test_feedback:
    initial: |
      ### 3. Issue Description
      {{ issue_description }}

    failure: |
      ### 3. Test Failure Feedback
      The previous patch failed. Here is the error diagnostic:
      
      Error Message:
      {{ error_message }}
      
      Failed Test Case:
      {{ failed_test_name }}

  postamble: |
    ### 4. Output Format Instructions
      Your output should be in the following JSON format, where location indicates the line number of the patch in [buggy method]. 
      Do not generate anything else besides the JSON file.
        <JSON>
        {
           "action" : " ", "patch" : " ", "location" : " "
        }
        </JSON>
