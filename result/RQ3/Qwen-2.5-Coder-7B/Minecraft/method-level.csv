bug_id,patch
29,"132 }
133 
134 /* randomize hw params */
135 static int alsa_set_hw_params(void)
136 {
137 	snd_pcm_hw_params_t *hwparams;
138 	snd_pcm_uframes_t frames;
139 	const char *cmd;
140 	unsigned int rate;
141 	int rc, fmt, dir;
142 
143 	snd_pcm_hw_params_alloca(&hwparams);
144 
145 	cmd = ""snd_pcm_hw_params_any"";
146 	rc = snd_pcm_hw_params_any(alsa_handle, hwparams);
147 	if (rc < 0)
148 		goto error;
149 
150 	cmd = ""snd_pcm_hw_params_set_access"";
151 	rc = snd_pcm_hw_params_set_access(alsa_handle, hwparams,
152 			SND_PCM_ACCESS_RW_INTERLEAVED);
153 	if (rc < 0)
154 		goto error;
155 
156 	fmt = snd_pcm_build_linear_format(sf_get_bits(alsa_sf), sf_get_bits(alsa_sf),
157 			sf_get_signed(alsa_sf) ? 0 : 1,
158 			sf_get_bigendian(alsa_sf));
159 	cmd = ""snd_pcm_hw_params_set_format"";
160 	rc = snd_pcm_hw_params_set_format(alsa_handle, hwparams, fmt);
161 	if (rc < 0)
162 		goto error;
163 
164 	alsa_fmt = fmt;
165 
166 	cmd = ""snd_pcm_hw_params_set_channels"";
167 	rc = snd_pcm_hw_params_set_channels(alsa_handle, hwparams, sf_get_channels(alsa_sf));
168 	if (rc < 0)
169 		goto error;
170 
171 	cmd = ""snd_pcm_hw_params_set_rate"";
172 	rate = sf_get_rate(alsa_sf);
173 	dir = 0;
174 	rc = snd_pcm_hw_params_set_rate_near(alsa_handle, hwparams, &rate, &dir);
175 	if (rc < 0)
176 		goto error;
177 	d_print(""rate=%d\n"", rate);
178 
179 #if defined(SET_BUFFERTIME)
180 	/* fscking alsa */
181 	alsa_buffer_time = 500e3;
182 	alsa_period_time = 50e3;
183 
184 	cmd = ""snd_pcm_hw_params_set_buffer_time_near"";
185 	dir = 0;
186 	rc = snd_pcm_hw_params_set_buffer_time_near(alsa_handle, hwparams, &alsa_buffer_time, &dir);
187 	if (rc < 0)
188 		goto error;
189 
190 	cmd = ""snd_pcm_hw_params_set_period_time_near"";
191 	dir = 0;
192 	rc = snd_pcm_hw_params_set_period_time_near(alsa_handle, hwparams, &alsa_period_time, &dir);
193 	if (rc < 0)
194 		goto error;
195 #endif
196 
197 	alsa_can_pause = snd_pcm_hw_params_can_pause(hwparams);
198 	d_print(""can pause = %d\n"", alsa_can_pause);
199 
200 	rc = snd_pcm_hw_params_get_period_size(hwparams, &frames, &dir);
201 	if (rc < 0) {
202 		alsa_period_size = -1;
203 	} else {
204 		alsa_period_size = frames * alsa_frame_size;
205 	}
206 
207 	rc = snd_pcm_hw_params_get_buffer_size(hwparams, &frames);
208 	if (rc < 0) {
209 		alsa_buffer_size = -1;
210 	} else {
211 		alsa_buffer_size = frames * alsa_frame_size;
212 	}
213 	d_print(""period_size = %d (dir = %d), buffer_size = %d\n"",
214 			alsa_period_size, dir, alsa_buffer_size);
215 
216 	cmd = ""snd_pcm_hw_params"";
217 	rc = snd_pcm_hw_params(alsa_handle, hwparams);
218 	if (rc < 0)
219 		goto error;
220 	return 0;
221 error:
222 	d_print(""%s: error: %s\n"", cmd, snd_strerror(rc));
223 	return rc;
224 }
225 
226 /* randomize sw params */"
36,"170 	}
171 }
172 
173 static int do_glob_match(struct list_head *head, struct list_head *first, const char *text)
174 {
175 	struct list_head *item = first;
176 
177 	while (item != head) {
178 		struct glob_item *gitem;
179 
180 		gitem = container_of(item, struct glob_item, node);
181 		if (gitem->type == GLOB_TEXT) {
182 			int len = u_strlen(gitem->text);
183 
184 			if (u_strncasecmp(gitem->text, text, len))
185 				return 0;
186 			text += strlen(gitem->text);
187 		} else if (gitem->type == GLOB_QMARK) {
188 			uchar u;
189 			int idx = 0;
190 
191 			u_get_char(text, &idx, &u);
192 			if (u == 0)
193 				return 0;
194 			text += idx;
195 		} else if (gitem->type == GLOB_STAR) {
196 			/* after star there MUST be normal text (or nothing),
197 			 * question marks have been moved before this star and
198 			 * other stars have been sripped (see simplify)
199 			 */
200 			struct list_head *next;
201 			struct glob_item *next_gi;
202 			const char *t;
203 			int tlen;
204 
205 			next = item->next;
206 			if (next == head) {
207 				/* this star was the last item => matched */
208 				return 1;
209 			}
210 			next_gi = container_of(next, struct glob_item, node);
211 			BUG_ON(next_gi->type != GLOB_TEXT);
212 			t = next_gi->text;
213 			tlen = strlen(t);
214 			while (1) {
215 				const char *pos;
216 
217 				pos = u_strcasestr_filename(text, t);
218 				if (pos == NULL)
219 					return 0;
220 				if (do_glob_match(head, next->next, pos + tlen))
221 					return 1;
222 				text = pos + 1;
223 			}
224 		}
225 		item = item->next;
226 	}
227 	return text[0] == 0;
228 }
229 
230 int glob_match(struct list_head *head, const char *text)"
42,"137  * aling_left:
138  *     1 => aling left. 0 => align right
139  */
140 static void print_str(char *buf, int *idx, const char *str, int width, int align_left)
141 {
142 	int d = *idx;
143 
144 	if (width) {
145 		int ws_len;
146 		int i = 0;
147 
148 		if (align_left) {
149 			i = width;
150 			d += u_copy_chars(buf + d, str, &i);
151 
152 			ws_len = width - i;
153 			memset(buf + d, ' ', ws_len);
154 			d += ws_len;
155 		} else {
156 			int s = 0;
157 
158 			ws_len = width - u_str_width(str);
159 
160 			if (ws_len > 0) {
161 				memset(buf + d, ' ', ws_len);
162 				d += ws_len;
163 				i += ws_len;
164 			}
165 
166 			if (ws_len < 0) {
167 				int w, c = -ws_len;
168 				uchar u;
169 
170 				while (c > 0) {
171 					u_get_char(str, &s, &u);
172 					w = u_char_width(u);
173 					c -= w;
174 				}
175 				if (c < 0) {
176 					/* gaah, skipped too much */
177 					if (u_char_width(u) == 2) {
178 						/* double-byte */
179 						buf[d++] = ' ';
180 					} else {
181 						/* <xx> */
182 						if (c == -3)
183 							buf[d++] = hex_tab[(u >> 4) & 0xf];
184 						if (c <= -2)
185 							buf[d++] = hex_tab[u & 0xf];
186 						buf[d++] = '>';
187 					}
188 				}
189 			}
190 
191 			if (width - i > 0) {
192 				int w = width - i;
193 
194 				d += u_copy_chars(buf + d, str + s, &w);
195 			}
196 		}
197 	} else {
198 		int s = 0;
199 		uchar u;
200 
201 		while (1) {
202 			u_get_char(str, &s, &u);
203 			if (u == 0)
204 				break;
205 			u_set_char(buf, &d, u);
206 		}
207 	}
208 	*idx = d;
209 }
210 
211 static void print(char *str, const char *format, const struct format_option *fopts)"
8,"123 	*iptr = i + 1;
124 }
125 
126 static int mad_read_comments(struct input_plugin_data *ip_data,
127 		struct keyval **comments)
128 {
129 	ID3 *id3;
130 	struct keyval *c;
131 	int fd, rc, save, i;
132 
133 	fd = open(ip_data->filename, O_RDONLY);
134 	if (fd == -1) {
135 		return -1;
136 	}
137 
138 	id3 = id3_new();
139 	rc = id3_read_tags(id3, fd, ID3_V1 | ID3_V2);
140 	save = errno;
141 	close(fd);
142 	errno = save;
143 	if (rc) {
144 		if (rc == -1) {
145 			d_print(""error: %s\n"", strerror(errno));
146 			return -1;
147 		}
148 		d_print(""corrupted tag?\n"");
149 		*comments = xnew0(struct keyval, 1);
150 		return 0;
151 	}
152 
153 	c = xnew0(struct keyval, NUM_ID3_KEYS + 1);
154 	i = 0;
155 	get_comment(c, &i, id3, ID3_ARTIST, ""artist"");
156 	get_comment(c, &i, id3, ID3_ALBUM, ""album"");
157 	get_comment(c, &i, id3, ID3_TITLE, ""title"");
158 	get_comment(c, &i, id3, ID3_DATE, ""date"");
159 	get_comment(c, &i, id3, ID3_GENRE, ""genre"");
160 	get_comment(c, &i, id3, ID3_DISC, ""discnumber"");
161 	get_comment(c, &i, id3, ID3_TRACK, ""tracknumber"");
162 	*comments = c;
163 	id3_free(id3);
164 	return 0;
165 }
166 
167 static int mad_duration(struct input_plugin_data *ip_data)"
