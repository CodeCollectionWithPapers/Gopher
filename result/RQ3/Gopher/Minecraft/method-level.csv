bug_id,patch
13,"127 	return 0;
128 }
129 
130 static int mod_read_comments(struct input_plugin_data *ip_data, struct keyval **comments)
131 {
132 	struct mod_private *priv = ip_data->private;
133 	struct keyval *c;
134 	const char *name;
135 
136 	c = xnew0(struct keyval, 2);
137 	name = ModPlug_GetName(priv->file);
138 	if (name != NULL && *name != 0) {
139 		c[0].key = xstrdup(""title"");
140 		c[0].val = xstrdup(name);
141 	}
142 	*comments = c;
143 	return 0;
144 }
145 
146 static int mod_duration(struct input_plugin_data *ip_data)"
19,"234 	return 0;
235 }
236 
237 static int wav_read_comments(struct input_plugin_data *ip_data,
238 		struct keyval **comments)
239 {
240 	*comments = xnew0(struct keyval, 1);
241 	return 0;
242 }
243 
244 static int wav_duration(struct input_plugin_data *ip_data)"
25,"277 	return rc;
278 }
279 
280 static int op_alsa_open(sample_format_t sf)
281 {
282 	int rc;
283 
284 	alsa_sf = sf;
285 	alsa_frame_size = sf_get_frame_size(alsa_sf);
286 
287 	rc = snd_pcm_open(&alsa_handle, alsa_dsp_device, SND_PCM_STREAM_PLAYBACK, 0);
288 	if (rc < 0) {
289 		d_print(""snd_pcm_open: error: %s\n"", snd_strerror(rc));
290 		goto error;
291 	}
292 
293 	rc = alsa_set_hw_params();
294 	if (rc)
295 		goto close_error;
296 	rc = alsa_set_sw_params();
297 	if (rc)
298 		goto close_error;
299 
300 	rc = snd_pcm_prepare(alsa_handle);
301 	if (rc < 0) {
302 		d_print(""snd_pcm_prepare: error: %s\n"", snd_strerror(rc));
303 		goto close_error;
304 	}
305 	d_print(""opened\n"");
306 	return 0;
307 close_error:
308 	snd_pcm_close(alsa_handle);
309 error:
310 	return alsa_error_to_op_error(rc);
311 }
312 
313 static int op_alsa_close(void)"
36,"170 	}
171 }
172 
173 static int do_glob_match(struct list_head *head, struct list_head *first, const char *text)
174 {
175 	struct list_head *item = first;
176 
177 	while (item != head) {
178 		struct glob_item *gitem;
179 
180 		gitem = container_of(item, struct glob_item, node);
181 		if (gitem->type == GLOB_TEXT) {
182 			int len = u_strlen(gitem->text);
183 
184 			if (u_strncasecmp(gitem->text, text, len))
185 				return 0;
186 			text += strlen(gitem->text);
187 		} else if (gitem->type == GLOB_QMARK) {
188 			uchar u;
189 			int idx = 0;
190 
191 			u_get_char(text, &idx, &u);
192 			if (u == 0)
193 				return 0;
194 			text += idx;
195 		} else if (gitem->type == GLOB_STAR) {
196 			/* after star there MUST be normal text (or nothing),
197 			 * question marks have been moved before this star and
198 			 * other stars have been sripped (see simplify)
199 			 */
200 			struct list_head *next;
201 			struct glob_item *next_gi;
202 			const char *t;
203 			int tlen;
204 
205 			next = item->next;
206 			if (next == head) {
207 				/* this star was the last item => matched */
208 				return 1;
209 			}
210 			next_gi = container_of(next, struct glob_item, node);
211 			BUG_ON(next_gi->type != GLOB_TEXT);
212 			t = next_gi->text;
213 			tlen = strlen(t);
214 			while (1) {
215 				const char *pos;
216 
217 				pos = u_strcasestr_filename(text, t);
218 				if (pos == NULL)
219 					return 0;
220 				if (do_glob_match(head, next->next, pos + tlen))
221 					return 1;
222 				text = pos + 1;
223 			}
224 		}
225 		item = item->next;
226 	}
227 	return text[0] == 0;
228 }
229 
230 int glob_match(struct list_head *head, const char *text)"
42,"137  * aling_left:
138  *     1 => aling left. 0 => align right
139  */
140 static void print_str(char *buf, int *idx, const char *str, int width, int align_left)
141 {
142 	int d = *idx;
143 
144 	if (width) {
145 		int ws_len;
146 		int i = 0;
147 
148 		if (align_left) {
149 			i = width;
150 			d += u_copy_chars(buf + d, str, &i);
151 
152 			ws_len = width - i;
153 			memset(buf + d, ' ', ws_len);
154 			d += ws_len;
155 		} else {
156 			int s = 0;
157 
158 			ws_len = width - u_str_width(str);
159 
160 			if (ws_len > 0) {
161 				memset(buf + d, ' ', ws_len);
162 				d += ws_len;
163 				i += ws_len;
164 			}
165 
166 			if (ws_len < 0) {
167 				int w, c = -ws_len;
168 				uchar u;
169 
170 				while (c > 0) {
171 					u_get_char(str, &s, &u);
172 					w = u_char_width(u);
173 					c -= w;
174 				}
175 				if (c < 0) {
176 					/* gaah, skipped too much */
177 					if (u_char_width(u) == 2) {
178 						/* double-byte */
179 						buf[d++] = ' ';
180 					} else {
181 						/* <xx> */
182 						if (c == -3)
183 							buf[d++] = hex_tab[(u >> 4) & 0xf];
184 						if (c <= -2)
185 							buf[d++] = hex_tab[u & 0xf];
186 						buf[d++] = '>';
187 					}
188 				}
189 			}
190 
191 			if (width - i > 0) {
192 				int w = width - i;
193 
194 				d += u_copy_chars(buf + d, str + s, &w);
195 			}
196 		}
197 	} else {
198 		int s = 0;
199 		uchar u;
200 
201 		while (1) {
202 			u_get_char(str, &s, &u);
203 			if (u == 0)
204 				break;
205 			u_set_char(buf, &d, u);
206 		}
207 	}
208 	*idx = d;
209 }
210 
211 static void print(char *str, const char *format, const struct format_option *fopts)"
44,"137  * aling_left:
138  *     1 => aling left. 0 => align right
139  */
140 static void print_str(char *buf, int *idx, const char *str, int width, int align_left)
141 {
142 	int d = *idx;
143 
144 	if (width) {
145 		int ws_len;
146 		int i = 0;
147 
148 		if (align_left) {
149 			i = width;
150 			d += u_copy_chars(buf + d, str, &i);
151 
152 			ws_len = width - i;
153 			memset(buf + d, ' ', ws_len);
154 			d += ws_len;
155 		} else {
156 			int s = 0;
157 
158 			ws_len = width - u_str_width(str);
159 
160 			if (ws_len > 0) {
161 				memset(buf + d, ' ', ws_len);
162 				d += ws_len;
163 				i += ws_len;
164 			}
165 
166 			if (ws_len < 0) {
167 				int w, c = -ws_len;
168 				uchar u;
169 
170 				while (c > 0) {
171 					u_get_char(str, &s, &u);
172 					w = u_char_width(u);
173 					c -= w;
174 				}
175 				if (c < 0) {
176 					/* gaah, skipped too much */
177 					if (u_char_width(u) == 2) {
178 						/* double-byte */
179 						buf[d++] = ' ';
180 					} else {
181 						/* <xx> */
182 						if (c == -3)
183 							buf[d++] = hex_tab[(u >> 4) & 0xf];
184 						if (c <= -2)
185 							buf[d++] = hex_tab[u & 0xf];
186 						buf[d++] = '>';
187 					}
188 				}
189 			}
190 
191 			if (width - i > 0) {
192 				int w = width - i;
193 
194 				d += u_copy_chars(buf + d, str + s, &w);
195 			}
196 		}
197 	} else {
198 		int s = 0;
199 		uchar u;
200 
201 		while (1) {
202 			u_get_char(str, &s, &u);
203 			if (u == 0)
204 				break;
205 			u_set_char(buf, &d, u);
206 		}
207 	}
208 	*idx = d;
209 }
210 
211 static void print(char *str, const char *format, const struct format_option *fopts)"
5,"445 	return 0;
446 }
447 
448 static int flac_read_comments(struct input_plugin_data *ip_data, struct keyval **comments)
449 {
450 	struct flac_private *priv = ip_data->private;
451 
452 	if (priv->comments) {
453 		*comments = comments_dup(priv->comments);
454 	} else {
455 		*comments = xnew0(struct keyval, 1);
456 	}
457 	return 0;
458 }
459 
460 static int flac_duration(struct input_plugin_data *ip_data)"
8,"123 	*iptr = i + 1;
124 }
125 
126 static int mad_read_comments(struct input_plugin_data *ip_data,
127 		struct keyval **comments)
128 {
129 	ID3 *id3;
130 	struct keyval *c;
131 	int fd, rc, save, i;
132 
133 	fd = open(ip_data->filename, O_RDONLY);
134 	if (fd == -1) {
135 		return -1;
136 	}
137 
138 	id3 = id3_new();
139 	rc = id3_read_tags(id3, fd, ID3_V1 | ID3_V2);
140 	save = errno;
141 	close(fd);
142 	errno = save;
143 	if (rc) {
144 		if (rc == -1) {
145 			d_print(""error: %s\n"", strerror(errno));
146 			return -1;
147 		}
148 		d_print(""corrupted tag?\n"");
149 		*comments = xnew0(struct keyval, 1);
150 		return 0;
151 	}
152 
153 	c = xnew0(struct keyval, NUM_ID3_KEYS + 1);
154 	i = 0;
155 	get_comment(c, &i, id3, ID3_ARTIST, ""artist"");
156 	get_comment(c, &i, id3, ID3_ALBUM, ""album"");
157 	get_comment(c, &i, id3, ID3_TITLE, ""title"");
158 	get_comment(c, &i, id3, ID3_DATE, ""date"");
159 	get_comment(c, &i, id3, ID3_GENRE, ""genre"");
160 	get_comment(c, &i, id3, ID3_DISC, ""discnumber"");
161 	get_comment(c, &i, id3, ID3_TRACK, ""tracknumber"");
162 	*comments = c;
163 	id3_free(id3);
164 	return 0;
165 }
166 
167 static int mad_duration(struct input_plugin_data *ip_data)"
