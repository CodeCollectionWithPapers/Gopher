{
    "Cli-11_testPrintOptionWithEmptyArgNameUsage": "    public void testPrintOptionWithEmptyArgNameUsage() {\n        Option option = new Option(\"f\", true, null);\n        option.setArgName(\"\");\n        option.setRequired(true);\n\n        Options options = new Options();\n        options.addOption(option);\n\n        StringWriter out = new StringWriter();\n\n        HelpFormatter formatter = new HelpFormatter();\n        formatter.printUsage(new PrintWriter(out), 80, \"app\", options);\n\n        assertEquals(\"usage: app -f\" + EOL, out.toString());\n    }",
    "Cli-12_testLongWithEqual": "    public void testLongWithEqual() throws Exception\n    {\n        String[] args = new String[] { \"--foo=bar\" };\n\n        Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasArg().create('f'));\n\n        Parser parser = new GnuParser();\n        CommandLine cl = parser.parse(options, args);\n\n        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n    }",
    "Cli-12_testLongWithEqualSingleDash": "    public void testLongWithEqualSingleDash() throws Exception\n    {\n        String[] args = new String[] { \"-foo=bar\" };\n\n        Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasArg().create('f'));\n\n        Parser parser = new GnuParser();\n        CommandLine cl = parser.parse(options, args);\n\n        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n    }",
    "Cli-12_testShortWithEqual": "    public void testShortWithEqual() throws Exception\n    {\n        String[] args = new String[] { \"-f=bar\" };\n\n        Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasArg().create('f'));\n\n        Parser parser = new GnuParser();\n        CommandLine cl = parser.parse(options, args);\n\n        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n    }",
    "Cli-14_testFileValidator": "\tpublic void testFileValidator() {\n\t\tfinal DefaultOptionBuilder obuilder = new DefaultOptionBuilder();\n        final ArgumentBuilder abuilder = new ArgumentBuilder();\n        final GroupBuilder gbuilder = new GroupBuilder();\n        DefaultOption fileNameOption = obuilder.withShortName(\"f\")\n                .withLongName(\"file-name\").withRequired(true).withDescription(\n                        \"name of an existing file\").withArgument(\n                        abuilder.withName(\"file-name\").withValidator(\n                                FileValidator.getExistingFileInstance())\n                                .create()).create();\n        Group options = gbuilder.withName(\"options\").withOption(fileNameOption)\n                .create();\n        Parser parser = new Parser();\n        parser.setHelpTrigger(\"--help\");\n        parser.setGroup(options);\n\n        final String fileName = \"src/test/org/apache/commons/cli2/bug/BugCLI144Test.java\";\n        CommandLine cl = parser\n                .parseAndHelp(new String[] { \"--file-name\", fileName });\n        assertNotNull(cl);\n        assertEquals(\"Wrong file\", new File(fileName), cl.getValue(fileNameOption));\n\t}",
    "Cli-15_testSingleOptionMaximumNumberOfArgument": "    public void testSingleOptionMaximumNumberOfArgument() throws Exception {\n        String[] args = new String[]{\"-b\", \"1\", \"2\"};\n        final ArgumentBuilder abuilder = new ArgumentBuilder();\n        final DefaultOptionBuilder obuilder = new DefaultOptionBuilder();\n        final GroupBuilder gbuilder = new GroupBuilder();\n\n        DefaultOption bOption = obuilder.withShortName(\"b\")\n                .withLongName(\"b\")\n                .withArgument(abuilder.withName(\"b\")\n                        .withMinimum(2)\n                        .withMaximum(4)\n                        .withDefault(\"100\")\n                        .withDefault(\"1000\")\n                        .withDefault(\"10000\")\n                        .create())\n                .create();\n\n        Group options = gbuilder\n                .withName(\"options\")\n                .withOption(bOption)\n                .create();\n\n        Parser parser = new Parser();\n        parser.setHelpTrigger(\"--help\");\n        parser.setGroup(options);\n        CommandLine cl = parser.parse(args);\n        CommandLine cmd = cl;\n        assertNotNull(cmd);\n        List b = cmd.getValues(\"-b\");\n        assertEquals(\"[1, 2, 10000]\", b + \"\");\n    }",
    "Cli-15_testSingleOptionSingleArgument": "    public void testSingleOptionSingleArgument() throws Exception {\n        Parser parser = createDefaultValueParser(new String[]{\"100\", \"1000\"});\n        String enteredValue1 = \"1\";\n        String[] args = new String[]{\"-b\", enteredValue1};\n        CommandLine cl = parser.parse(args);\n        CommandLine cmd = cl;\n        assertNotNull(cmd);\n        List b = cmd.getValues(\"-b\");\n        assertEquals(\"[\" + enteredValue1 + \", 1000]\", b + \"\");\n    }",
    "Cli-17_testStopBursting": "    public void testStopBursting() throws Exception\n    {\n        String[] args = new String[] { \"-azc\" };\n\n        CommandLine cl = parser.parse(options, args, true);\n        assertTrue( \"Confirm -a is set\", cl.hasOption(\"a\") );\n        assertFalse( \"Confirm -c is not set\", cl.hasOption(\"c\") );\n\n        assertTrue( \"Confirm  1 extra arg: \" + cl.getArgList().size(), cl.getArgList().size() == 1);\n        assertTrue(cl.getArgList().contains(\"zc\"));\n    }",
    "Cli-19_testUnrecognizedOption2": "    public void testUnrecognizedOption2() throws Exception\n    {\n        String[] args = new String[] { \"-z\", \"-abtoast\", \"foo\", \"bar\" };\n\n        try\n        {\n            parser.parse(options, args);\n            fail(\"UnrecognizedOptionException wasn't thrown\");\n        }\n        catch (UnrecognizedOptionException e)\n        {\n            assertEquals(\"-z\", e.getOption());\n        }\n    }",
    "Cli-20_testStop3": "    public void testStop3() throws Exception\n    {\n        String[] args = new String[]{\"--zop==1\",\n                                     \"-abtoast\",\n                                     \"--b=bar\"};\n\n        CommandLine cl = parser.parse(options, args, true);\n\n        assertFalse(\"Confirm -a is not set\", cl.hasOption(\"a\"));\n        assertFalse(\"Confirm -b is not set\", cl.hasOption(\"b\"));\n        assertTrue(\"Confirm  3 extra args: \" + cl.getArgList().size(), cl.getArgList().size() == 3);\n    }",
    "Cli-23_testInfiniteLoop": "    public void testInfiniteLoop() {\n        HelpFormatter formatter = new HelpFormatter();\n        formatter.setWidth(20);\n        formatter.printHelp(\"app\", options); // used to hang & crash\n    }",
    "Cli-23_testPrintHelpLongLines": "    public void testPrintHelpLongLines() throws ParseException, IOException {\n        // Constants used for options\n        final String OPT = \"-\";\n\n        final String OPT_COLUMN_NAMES = \"l\";\n\n        final String OPT_CONNECTION = \"c\";\n\n        final String OPT_DESCRIPTION = \"e\";\n\n        final String OPT_DRIVER = \"d\";\n\n        final String OPT_DRIVER_INFO = \"n\";\n\n        final String OPT_FILE_BINDING = \"b\";\n\n        final String OPT_FILE_JDBC = \"j\";\n\n        final String OPT_FILE_SFMD = \"f\";\n\n        final String OPT_HELP = \"h\";\n\n        final String OPT_HELP_ = \"help\";\n\n        final String OPT_INTERACTIVE = \"i\";\n\n        final String OPT_JDBC_TO_SFMD = \"2\";\n\n        final String OPT_JDBC_TO_SFMD_L = \"jdbc2sfmd\";\n\n        final String OPT_METADATA = \"m\";\n\n        final String OPT_PARAM_MODES_INT = \"o\";\n\n        final String OPT_PARAM_MODES_NAME = \"O\";\n\n        final String OPT_PARAM_NAMES = \"a\";\n\n        final String OPT_PARAM_TYPES_INT = \"y\";\n\n        final String OPT_PARAM_TYPES_NAME = \"Y\";\n\n        final String OPT_PASSWORD = \"p\";\n\n        final String OPT_PASSWORD_L = \"password\";\n\n        final String OPT_SQL = \"s\";\n\n        final String OPT_SQL_L = \"sql\";\n\n        final String OPT_SQL_SPLIT_DEFAULT = \"###\";\n\n        final String OPT_SQL_SPLIT_L = \"splitSql\";\n\n        final String OPT_STACK_TRACE = \"t\";\n\n        final String OPT_TIMING = \"g\";\n\n        final String OPT_TRIM_L = \"trim\";\n\n        final String OPT_USER = \"u\";\n\n        final String OPT_WRITE_TO_FILE = \"w\";\n        \n        final String _PMODE_IN = \"IN\";\n\n        final String _PMODE_INOUT = \"INOUT\";\n\n        final String _PMODE_OUT = \"OUT\";\n        \n        final String _PMODE_UNK = \"Unknown\";\n        \n        final String PMODES = _PMODE_IN + \", \" + _PMODE_INOUT + \", \" + _PMODE_OUT + \", \" + _PMODE_UNK;\n        \n        // Options build\n        Options commandLineOptions;\n        commandLineOptions = new Options();\n        commandLineOptions.addOption(OPT_HELP, OPT_HELP_, false, \"Prints help and quits\");\n        commandLineOptions.addOption(OPT_DRIVER, \"driver\", true, \"JDBC driver class name\");\n        commandLineOptions.addOption(OPT_DRIVER_INFO, \"info\", false, \"Prints driver information and properties. If \"\n            + OPT\n            + OPT_CONNECTION\n            + \" is not specified, all drivers on the classpath are displayed.\");\n        commandLineOptions.addOption(OPT_CONNECTION, \"url\", true, \"Connection URL\");\n        commandLineOptions.addOption(OPT_USER, \"user\", true, \"A database user name\");\n        commandLineOptions\n                .addOption(\n                        OPT_PASSWORD,\n                        OPT_PASSWORD_L,\n                        true,\n                        \"The database password for the user specified with the \"\n                            + OPT\n                            + OPT_USER\n                            + \" option. You can obfuscate the password with org.mortbay.jetty.security.Password, see http://docs.codehaus.org/display/JETTY/Securing+Passwords\");\n        commandLineOptions.addOption(OPT_SQL, OPT_SQL_L, true, \"Runs SQL or {call stored_procedure(?, ?)} or {?=call function(?, ?)}\");\n        commandLineOptions.addOption(OPT_FILE_SFMD, \"sfmd\", true, \"Writes a SFMD file for the given SQL\");\n        commandLineOptions.addOption(OPT_FILE_BINDING, \"jdbc\", true, \"Writes a JDBC binding node file for the given SQL\");\n        commandLineOptions.addOption(OPT_FILE_JDBC, \"node\", true, \"Writes a JDBC node file for the given SQL (internal debugging)\");\n        commandLineOptions.addOption(OPT_WRITE_TO_FILE, \"outfile\", true, \"Writes the SQL output to the given file\");\n        commandLineOptions.addOption(OPT_DESCRIPTION, \"description\", true,\n                \"SFMD description. A default description is used if omited. Example: \" + OPT + OPT_DESCRIPTION + \" \\\"Runs such and such\\\"\");\n        commandLineOptions.addOption(OPT_INTERACTIVE, \"interactive\", false,\n                \"Runs in interactive mode, reading and writing from the console, 'go' or '/' sends a statement\");\n        commandLineOptions.addOption(OPT_TIMING, \"printTiming\", false, \"Prints timing information\");\n        commandLineOptions.addOption(OPT_METADATA, \"printMetaData\", false, \"Prints metadata information\");\n        commandLineOptions.addOption(OPT_STACK_TRACE, \"printStack\", false, \"Prints stack traces on errors\");\n        Option option = new Option(OPT_COLUMN_NAMES, \"columnNames\", true, \"Column XML names; default names column labels. Example: \"\n            + OPT\n            + OPT_COLUMN_NAMES\n            + \" \\\"cname1 cname2\\\"\");\n        commandLineOptions.addOption(option);\n        option = new Option(OPT_PARAM_NAMES, \"paramNames\", true, \"Parameter XML names; default names are param1, param2, etc. Example: \"\n            + OPT\n            + OPT_PARAM_NAMES\n            + \" \\\"pname1 pname2\\\"\");\n        commandLineOptions.addOption(option);\n        //\n        OptionGroup pOutTypesOptionGroup = new OptionGroup();\n        String pOutTypesOptionGroupDoc = OPT + OPT_PARAM_TYPES_INT + \" and \" + OPT + OPT_PARAM_TYPES_NAME + \" are mutually exclusive.\";\n        final String typesClassName = Types.class.getName();\n        option = new Option(OPT_PARAM_TYPES_INT, \"paramTypes\", true, \"Parameter types from \"\n            + typesClassName\n            + \". \"\n            + pOutTypesOptionGroupDoc\n            + \" Example: \"\n            + OPT\n            + OPT_PARAM_TYPES_INT\n            + \" \\\"-10 12\\\"\");\n        commandLineOptions.addOption(option);\n        option = new Option(OPT_PARAM_TYPES_NAME, \"paramTypeNames\", true, \"Parameter \"\n            + typesClassName\n            + \" names. \"\n            + pOutTypesOptionGroupDoc\n            + \" Example: \"\n            + OPT\n            + OPT_PARAM_TYPES_NAME\n            + \" \\\"CURSOR VARCHAR\\\"\");\n        commandLineOptions.addOption(option);\n        commandLineOptions.addOptionGroup(pOutTypesOptionGroup);\n        //\n        OptionGroup modesOptionGroup = new OptionGroup();\n        String modesOptionGroupDoc = OPT + OPT_PARAM_MODES_INT + \" and \" + OPT + OPT_PARAM_MODES_NAME + \" are mutually exclusive.\";\n        option = new Option(OPT_PARAM_MODES_INT, \"paramModes\", true, \"Parameters modes (\"\n            + ParameterMetaData.parameterModeIn\n            + \"=IN, \"\n            + ParameterMetaData.parameterModeInOut\n            + \"=INOUT, \"\n            + ParameterMetaData.parameterModeOut\n            + \"=OUT, \"\n            + ParameterMetaData.parameterModeUnknown\n            + \"=Unknown\"\n            + \"). \"\n            + modesOptionGroupDoc\n            + \" Example for 2 parameters, OUT and IN: \"\n            + OPT\n            + OPT_PARAM_MODES_INT\n            + \" \\\"\"\n            + ParameterMetaData.parameterModeOut\n            + \" \"\n            + ParameterMetaData.parameterModeIn\n            + \"\\\"\");\n        modesOptionGroup.addOption(option);\n        option = new Option(OPT_PARAM_MODES_NAME, \"paramModeNames\", true, \"Parameters mode names (\"\n            + PMODES\n            + \"). \"\n            + modesOptionGroupDoc\n            + \" Example for 2 parameters, OUT and IN: \"\n            + OPT\n            + OPT_PARAM_MODES_NAME\n            + \" \\\"\"\n            + _PMODE_OUT\n            + \" \"\n            + _PMODE_IN\n            + \"\\\"\");\n        modesOptionGroup.addOption(option);\n        commandLineOptions.addOptionGroup(modesOptionGroup);\n        option = new Option(null, OPT_TRIM_L, true,\n                \"Trims leading and trailing spaces from all column values. Column XML names can be optionally specified to set which columns to trim.\");\n        option.setOptionalArg(true);\n        commandLineOptions.addOption(option);\n        option = new Option(OPT_JDBC_TO_SFMD, OPT_JDBC_TO_SFMD_L, true,\n                \"Converts the JDBC file in the first argument to an SMFD file specified in the second argument.\");\n        option.setArgs(2);\n        commandLineOptions.addOption(option);\n        this.testPrintHelp(commandLineOptions);\n    }",
    "Cli-24_testLongLineChunkingIndentIgnored": "    public void testLongLineChunkingIndentIgnored() throws ParseException, IOException {\n        Options options = new Options();\n        options.addOption(\"x\", \"extralongarg\", false, \"This description is Long.\" );\n        HelpFormatter formatter = new HelpFormatter();\n        StringWriter sw = new StringWriter();\n        formatter.printHelp(new PrintWriter(sw), 22, this.getClass().getName(), \"Header\", options, 0, 5, \"Footer\");\n        String expected = \"usage:\\n\" +\n                          \"       org.apache.comm\\n\" +\n                          \"       ons.cli.bug.Bug\\n\" +\n                          \"       CLI162Test\\n\" +\n                          \"Header\\n\" +\n                          \"-x,--extralongarg\\n\" +\n                          \"                     T\\n\" +\n                          \"                     h\\n\" +\n                          \"                     i\\n\" +\n                          \"                     s\\n\" +\n                          \"                     d\\n\" +\n                          \"                     e\\n\" +\n                          \"                     s\\n\" +\n                          \"                     c\\n\" +\n                          \"                     r\\n\" +\n                          \"                     i\\n\" +\n                          \"                     p\\n\" +\n                          \"                     t\\n\" +\n                          \"                     i\\n\" +\n                          \"                     o\\n\" +\n                          \"                     n\\n\" +\n                          \"                     i\\n\" +\n                          \"                     s\\n\" +\n                          \"                     L\\n\" +\n                          \"                     o\\n\" +\n                          \"                     n\\n\" +\n                          \"                     g\\n\" +\n                          \"                     .\\n\" +\n                          \"Footer\\n\";\n        assertEquals( \"Long arguments did not split as expected\", expected, sw.toString() );\n    }",
    "Cli-25_testLongLineChunkingIndentIgnored": "    public void testLongLineChunkingIndentIgnored() throws ParseException, IOException {\n        Options options = new Options();\n        options.addOption(\"x\", \"extralongarg\", false, \"This description is Long.\" );\n        HelpFormatter formatter = new HelpFormatter();\n        StringWriter sw = new StringWriter();\n        formatter.printHelp(new PrintWriter(sw), 22, this.getClass().getName(), \"Header\", options, 0, 5, \"Footer\");\n        System.err.println(sw.toString());\n        String expected = \"usage:\\n\" +\n                          \"       org.apache.comm\\n\" +\n                          \"       ons.cli.bug.Bug\\n\" +\n                          \"       CLI162Test\\n\" +\n                          \"Header\\n\" +\n                          \"-x,--extralongarg\\n\" +\n                          \" This description is\\n\" +\n                          \" Long.\\n\" +\n                          \"Footer\\n\";\n        assertEquals( \"Long arguments did not split as expected\", expected, sw.toString() );\n    }",
    "Cli-26_testBuilderIsResettedAlways": "    public void testBuilderIsResettedAlways() {\n        try\n        {\n            OptionBuilder.withDescription(\"JUnit\").create('\"');\n            fail(\"IllegalArgumentException expected\");\n        }\n        catch (IllegalArgumentException e)\n        {\n            // expected\n        }\n        assertNull(\"we inherited a description\", OptionBuilder.create('x').getDescription());\n\n        try\n        {\n            OptionBuilder.withDescription(\"JUnit\").create();\n            fail(\"IllegalArgumentException expected\");\n        }\n        catch (IllegalArgumentException e)\n        {\n            // expected\n        }\n        assertNull(\"we inherited a description\", OptionBuilder.create('x').getDescription());\n    }",
    "Cli-27_testOptionGroupLong": "    public void testOptionGroupLong() throws Exception\n    {\n        OptionGroup group = new OptionGroup();\n        group.addOption(OptionBuilder.withLongOpt(\"foo\").create());\n        group.addOption(OptionBuilder.withLongOpt(\"bar\").create());\n        \n        Options options = new Options();\n        options.addOptionGroup(group);\n        \n        CommandLine cl = parser.parse(options, new String[] { \"--bar\" });\n        \n        assertTrue(cl.hasOption(\"bar\"));\n        assertEquals(\"selected option\", \"bar\", group.getSelected());\n    }\n",
    "Cli-28_testPropertyOptionFlags": "    public void testPropertyOptionFlags() throws Exception\n    {\n        Properties properties = new Properties();\n        properties.setProperty( \"a\", \"true\" );\n        properties.setProperty( \"c\", \"yes\" );\n        properties.setProperty( \"e\", \"1\" );\n\n        Parser parser = new PosixParser();\n\n        CommandLine cmd = parser.parse(opts, null, properties);\n        assertTrue( cmd.hasOption(\"a\") );\n        assertTrue( cmd.hasOption(\"c\") );\n        assertTrue( cmd.hasOption(\"e\") );\n\n\n        properties = new Properties();\n        properties.setProperty( \"a\", \"false\" );\n        properties.setProperty( \"c\", \"no\" );\n        properties.setProperty( \"e\", \"0\" );\n\n        cmd = parser.parse(opts, null, properties);\n        assertTrue( !cmd.hasOption(\"a\") );\n        assertTrue( !cmd.hasOption(\"c\") );\n        assertTrue( cmd.hasOption(\"e\") ); // this option accepts as argument\n\n\n        properties = new Properties();\n        properties.setProperty( \"a\", \"TRUE\" );\n        properties.setProperty( \"c\", \"nO\" );\n        properties.setProperty( \"e\", \"TrUe\" );\n\n        cmd = parser.parse(opts, null, properties);\n        assertTrue( cmd.hasOption(\"a\") );\n        assertTrue( !cmd.hasOption(\"c\") );\n        assertTrue( cmd.hasOption(\"e\") );\n\n        \n        properties = new Properties();\n        properties.setProperty( \"a\", \"just a string\" );\n        properties.setProperty( \"e\", \"\" );\n\n        cmd = parser.parse(opts, null, properties);\n        assertTrue( !cmd.hasOption(\"a\") );\n        assertTrue( !cmd.hasOption(\"c\") );\n        assertTrue( cmd.hasOption(\"e\") );\n    } ",
    "Cli-29_testStripLeadingAndTrailingQuotes": "    public void testStripLeadingAndTrailingQuotes()\n    {\n        assertEquals(\"foo\", Util.stripLeadingAndTrailingQuotes(\"\\\"foo\\\"\"));\n        assertEquals(\"foo \\\"bar\\\"\", Util.stripLeadingAndTrailingQuotes(\"foo \\\"bar\\\"\"));\n        assertEquals(\"\\\"foo\\\" bar\", Util.stripLeadingAndTrailingQuotes(\"\\\"foo\\\" bar\"));\n        assertEquals(\"\\\"foo\\\" and \\\"bar\\\"\", Util.stripLeadingAndTrailingQuotes(\"\\\"foo\\\" and \\\"bar\\\"\"));\n        assertEquals(\"\\\"\", Util.stripLeadingAndTrailingQuotes(\"\\\"\"));\n    }",
    "Cli-32_testFindWrapPos": "    public void testFindWrapPos() throws Exception\n    {\n        HelpFormatter hf = new HelpFormatter();\n\n        String text = \"This is a test.\";\n        // text width should be max 8; the wrap position is 7\n        assertEquals(\"wrap position\", 7, hf.findWrapPos(text, 8, 0));\n        \n        // starting from 8 must give -1 - the wrap pos is after end\n        assertEquals(\"wrap position 2\", -1, hf.findWrapPos(text, 8, 8));\n        \n        // words longer than the width are cut\n        text = \"aaaa aa\";\n        assertEquals(\"wrap position 3\", 3, hf.findWrapPos(text, 3, 0));\n        \n        // last word length is equal to the width\n        text = \"aaaaaa aaaaaa\";\n        assertEquals(\"wrap position 4\", 6, hf.findWrapPos(text, 6, 0));\n        assertEquals(\"wrap position 4\", -1, hf.findWrapPos(text, 6, 7));\n    }",
    "Cli-32_testRenderWrappedTextWordCut": "    public void testRenderWrappedTextWordCut()\n    {\n        int width = 7;\n        int padding = 0;\n        String text = \"Thisisatest.\";\n        String expected = \"Thisisa\" + EOL + \n                          \"test.\";\n        \n        StringBuffer sb = new StringBuffer();\n        new HelpFormatter().renderWrappedText(sb, width, padding, text);\n        assertEquals(\"cut and wrap\", expected, sb.toString());\n    }",
    "Cli-35_testExactOptionNameMatch": "    public void testExactOptionNameMatch() throws ParseException {\n        new DefaultParser().parse(getOptions(), new String[]{\"--prefix\"});\n    }",
    "Cli-37_shouldParseShortOptionWithoutValue": "    public void shouldParseShortOptionWithoutValue() throws Exception {\n        String[] twoShortOptions = new String[]{\"-t1\", \"-last\"};\n\n        final CommandLine commandLine = parser.parse(options, twoShortOptions);\n\n        assertTrue(commandLine.hasOption(\"t1\"));\n        assertNotEquals(\"Second option has been used as value for first option\", \"-last\", commandLine.getOptionValue(\"t1\"));\n        assertTrue(\"Second option has not been detected\", commandLine.hasOption(\"last\"));\n    }",
    "Cli-38_shouldParseConcatenatedShortOptions": "    public void shouldParseConcatenatedShortOptions() throws Exception {\n        String[] concatenatedShortOptions = new String[] { \"-t1\", \"-ab\" };\n\n        final CommandLine commandLine = parser.parse(options, concatenatedShortOptions);\n\n        assertTrue(commandLine.hasOption(\"t1\"));\n        assertNull(commandLine.getOptionValue(\"t1\"));\n        assertTrue(commandLine.hasOption(\"a\"));\n        assertTrue(commandLine.hasOption(\"b\"));\n        assertFalse(commandLine.hasOption(\"last\"));\n    }",
    "Cli-40_testCreateValueInteger_failure": "    public void testCreateValueInteger_failure()\n            throws Exception\n    {\n        TypeHandler.createValue(\"just-a-string\", Integer.class);\n    }",
    "Cli-4_testMissingOptionException": "    public void testMissingOptionException() throws ParseException {\n        Options options = new Options();\n        options.addOption(OptionBuilder.isRequired().create(\"f\"));\n        try {\n            new PosixParser().parse(options, new String[0]);\n            fail(\"Expected MissingOptionException to be thrown\");\n        } catch (MissingOptionException e) {\n            assertEquals(\"Missing required option: f\", e.getMessage());\n        }\n    }",
    "Cli-4_testMissingOptionsException": "    public void testMissingOptionsException() throws ParseException {\n        Options options = new Options();\n        options.addOption(OptionBuilder.isRequired().create(\"f\"));\n        options.addOption(OptionBuilder.isRequired().create(\"x\"));\n        try {\n            new PosixParser().parse(options, new String[0]);\n            fail(\"Expected MissingOptionException to be thrown\");\n        } catch (MissingOptionException e) {\n            assertEquals(\"Missing required options: fx\", e.getMessage());\n        }\n    }",
    "Cli-5_testOrder": "    public void testOrder() throws ParseException {\n        Option optionA = new Option(\"a\", \"first\");\n        Options opts = new Options();\n        opts.addOption(optionA);\n        PosixParser posixParser = new PosixParser();\n        CommandLine line = posixParser.parse(opts, null);\n        assertFalse(line.hasOption(null));\n    }",
    "Cli-5_testStripLeadingHyphens": "    public void testStripLeadingHyphens() {\n        assertEquals(\"f\", Util.stripLeadingHyphens(\"-f\"));\n        assertEquals(\"foo\", Util.stripLeadingHyphens(\"--foo\"));\n        assertNull(Util.stripLeadingHyphens(null));\n    }",
    "Cli-8_testPrintWrapped": "   public void testPrintWrapped()\n      throws Exception\n   {\n      StringBuffer sb = new StringBuffer();\n      HelpFormatter hf = new HelpFormatter();\n\n      String text = \"This is a test.\";\n      String expected;\n\n      expected = \"This is a\" + hf.getNewLine() + \"test.\";\n      hf.renderWrappedText(sb, 12, 0, text);\n      assertEquals(\"single line text\", expected, sb.toString());\n\n      sb.setLength(0);\n      expected = \"This is a\" + hf.getNewLine() + \"    test.\";\n      hf.renderWrappedText(sb, 12, 4, text);\n      assertEquals(\"single line padded text\", expected, sb.toString());\n\n      text = \"  -p,--period <PERIOD>  PERIOD is time duration of form \" +\n          \"DATE[-DATE] where DATE has form YYYY[MM[DD]]\";\n\n      sb.setLength(0);\n      expected = \"  -p,--period <PERIOD>  PERIOD is time duration of\" +\n                 hf.getNewLine() +\n                 \"                        form DATE[-DATE] where DATE\" +\n                 hf.getNewLine() +\n                 \"                        has form YYYY[MM[DD]]\";\n      hf.renderWrappedText(sb, 53, 24, text);\n      assertEquals(\"single line padded text 2\", expected, sb.toString());\n\n      text =\n         \"aaaa aaaa aaaa\" + hf.getNewLine() +\n         \"aaaaaa\" + hf.getNewLine() +\n         \"aaaaa\";\n\n      expected = text;\n      sb.setLength(0);\n      hf.renderWrappedText(sb, 16, 0, text);\n      assertEquals(\"multi line text\", expected, sb.toString());\n\n      expected =\n         \"aaaa aaaa aaaa\" + hf.getNewLine() +\n         \"    aaaaaa\" + hf.getNewLine() +\n         \"    aaaaa\";\n      sb.setLength(0);\n      hf.renderWrappedText(sb, 16, 4, text);\n      assertEquals(\"multi-line padded text\", expected, sb.toString());\n   }",
    "Cli-9_testMissingOptionsException": "    public void testMissingOptionsException() throws ParseException {\n        Options options = new Options();\n        options.addOption(OptionBuilder.isRequired().create(\"f\"));\n        options.addOption(OptionBuilder.isRequired().create(\"x\"));\n        try {\n            new PosixParser().parse(options, new String[0]);\n            fail(\"Expected MissingOptionException to be thrown\");\n        } catch (MissingOptionException e) {\n            assertEquals(\"Missing required options: f, x\", e.getMessage());\n        }\n    }",
    "Cli-9_testMissingRequiredOptions": "    public void testMissingRequiredOptions()\n    {\n        String[] args = new String[] { \"-a\" };\n\n        _options.addOption( OptionBuilder.withLongOpt( \"cfile\" )\n                                     .hasArg()\n                                     .isRequired()\n                                     .withDescription( \"set the value of [c]\" )\n                                     .create( 'c' ) );\n\n        try\n        {\n            CommandLine cl = parser.parse(_options,args);\n            fail( \"exception should have been thrown\" );\n        }\n        catch (MissingOptionException e)\n        {\n            assertEquals( \"Incorrect exception message\", \"Missing required options: b, c\", e.getMessage() );\n        }\n        catch (ParseException e)\n        {\n            fail( \"expected to catch MissingOptionException\" );\n        }\n    }",
    "Closure-145_testDoLoopIECompatiblity": "  public void testDoLoopIECompatiblity() {\n    // Do loops within IFs cause syntax errors in IE6 and IE7.\n    assertPrint(\"function(){if(e1){do foo();while(e2)}else foo()}\",\n        \"function(){if(e1){do foo();while(e2)}else foo()}\");\n\n    assertPrint(\"function(){if(e1)do foo();while(e2)else foo()}\",\n        \"function(){if(e1){do foo();while(e2)}else foo()}\");\n\n    assertPrint(\"if(x){do{foo()}while(y)}else bar()\",\n        \"if(x){do foo();while(y)}else bar()\");\n\n    assertPrint(\"if(x)do{foo()}while(y);else bar()\",\n        \"if(x){do foo();while(y)}else bar()\");\n\n    assertPrint(\"if(x){do{foo()}while(y)}\",\n        \"if(x){do foo();while(y)}\");\n\n    assertPrint(\"if(x)do{foo()}while(y);\",\n        \"if(x){do foo();while(y)}\");\n\n    assertPrint(\"if(x)A:do{foo()}while(y);\",\n        \"if(x){A:do foo();while(y)}\");\n    \n    assertPrint(\"var i = 0;a: do{b: do{i++;break b;} while(0);} while(0);\",\n        \"var i=0;a:do{b:do{i++;break b}while(0)}while(0)\");\n  }",
    "Closure-145_testFunctionSafariCompatiblity": "  public void testFunctionSafariCompatiblity() {\n    // Functions within IFs cause syntax errors on Safari.\n    assertPrint(\"function(){if(e1){function goo(){return true}}else foo()}\",\n        \"function(){if(e1){function goo(){return true}}else foo()}\");\n\n    assertPrint(\"function(){if(e1)function goo(){return true}else foo()}\",\n        \"function(){if(e1){function goo(){return true}}else foo()}\");\n\n    assertPrint(\"if(e1){function goo(){return true}}\",\n        \"if(e1){function goo(){return true}}\");\n\n    assertPrint(\"if(e1)function goo(){return true}\",\n        \"if(e1){function goo(){return true}}\");\n\n    assertPrint(\"if(e1)A:function goo(){return true}\",\n        \"if(e1){A:function goo(){return true}}\");\n  }",
    "Closure-146_testEqCondition4": "  public void testEqCondition4() throws Exception {\n    FlowScope blind = newScope();\n    testBinop(blind,\n        Token.EQ,\n        createVar(blind, \"a\", VOID_TYPE),\n        createVar(blind, \"b\", VOID_TYPE),\n        Sets.newHashSet(\n            new TypedName(\"a\", VOID_TYPE),\n            new TypedName(\"b\", VOID_TYPE)),\n        Sets.newHashSet(\n            new TypedName(\"a\", NO_TYPE),\n            new TypedName(\"b\", NO_TYPE)));\n  }",
    "Closure-150_testCollectedFunctionStubLocal": "  public void testCollectedFunctionStubLocal() {\n    testSame(\n        \"(function() {\" +\n        \"/** @constructor */ function f() { \" +\n        \"  /** @return {number} */ this.foo;\" +\n        \"}\" +\n        \"var x = new f();\" +\n        \"});\");\n    ObjectType x = (ObjectType) findNameType(\"x\", lastLocalScope);\n    assertEquals(\"f\", x.toString());\n    assertTrue(x.hasProperty(\"foo\"));\n    assertEquals(\"function (this:f): number\",\n        x.getPropertyType(\"foo\").toString());\n    assertFalse(x.isPropertyTypeInferred(\"foo\"));\n  }",
    "Closure-150_testNamespacedFunctionStubLocal": "  public void testNamespacedFunctionStubLocal() {\n    testSame(\n        \"(function() {\" +\n        \"var goog = {};\" +\n        \"/** @param {number} x */ goog.foo;\" +\n        \"});\");\n\n    ObjectType goog = (ObjectType) findNameType(\"goog\", lastLocalScope);\n    assertTrue(goog.hasProperty(\"foo\"));\n    assertEquals(\"function (number): ?\",\n        goog.getPropertyType(\"foo\").toString());\n    assertTrue(goog.isPropertyTypeDeclared(\"foo\"));\n\n    assertEquals(lastLocalScope.getVar(\"goog.foo\").getType(),\n        goog.getPropertyType(\"foo\"));\n  }",
    "Closure-152_testBackwardsTypedefUse1": "  public void testBackwardsTypedefUse1() throws Exception {\n    testTypes(\n        \"/** @this {MyTypedef} */ function f() {}\" +\n        \"/** @typedef {string} */ var MyTypedef;\",\n        \"@this type of a function must be an object\\n\" +\n        \"Actual type: string\");\n  }",
    "Closure-152_testBackwardsTypedefUse2": "  public void testBackwardsTypedefUse2() throws Exception {\n    testTypes(\n        \"/** @this {MyTypedef} */ function f() {}\" +\n        \"/** @typedef {!(Date|Array)} */ var MyTypedef;\");\n  }",
    "Closure-152_testBackwardsTypedefUse3": "  public void testBackwardsTypedefUse3() throws Exception {\n    testTypes(\n        \"/** @this {MyTypedef} */ function f() {}\" +\n        \"/** @typedef {(Date|Array)} */ var MyTypedef;\",\n        \"@this type of a function must be an object\\n\" +\n        \"Actual type: (Array|Date|null)\");\n  }",
    "Closure-159_testIssue423": "  public void testIssue423() {\n    test(\n        \"(function($) {\\n\" +\n        \"  $.fn.multicheck = function(options) {\\n\" +\n        \"    initialize.call(this, options);\\n\" +\n        \"  };\\n\" +\n        \"\\n\" +\n        \"  function initialize(options) {\\n\" +\n        \"    options.checkboxes = $(this).siblings(':checkbox');\\n\" +\n        \"    preload_check_all.call(this);\\n\" +\n        \"  }\\n\" +\n        \"\\n\" +\n        \"  function preload_check_all() {\\n\" +\n        \"    $(this).data('checkboxes');\\n\" +\n        \"  }\\n\" +\n        \"})(jQuery)\",\n        \"(function($){\" +\n        \"  $.fn.multicheck=function(options$$1){\" +\n        \"    {\" +\n        \"     options$$1.checkboxes=$(this).siblings(\\\":checkbox\\\");\" +\n        \"     {\" +\n        \"       $(this).data(\\\"checkboxes\\\")\" +\n        \"     }\" +\n        \"    }\" +\n        \"  }\" +\n        \"})(jQuery)\");\n  }",
    "Closure-160_testCheckSymbolsOverrideForQuiet": "  public void testCheckSymbolsOverrideForQuiet() {\n    args.add(\"--warning_level=QUIET\");\n    args.add(\"--jscomp_error=undefinedVars\");\n    test(\"x = 3;\", VarCheck.UNDEFINED_VAR_ERROR);\n  }",
    "Closure-161_testIssue522": "  public void testIssue522() {\n    testSame(\"[][1] = 1;\");\n  }",
    "Closure-164_testMethodInference7": "  public void testMethodInference7() throws Exception {\n    testTypes(\n        \"/** @constructor */ function F() {}\" +\n        \"F.prototype.foo = function() { };\" +\n        \"/** @constructor \\n * @extends {F} */ \" +\n        \"function G() {}\" +\n        \"/** @override */ G.prototype.foo = function(x, y) { };\",\n        \"mismatch of the foo property type and the type of the property \" +\n        \"it overrides from superclass F\\n\" +\n        \"original: function (this:F): undefined\\n\" +\n        \"override: function (this:G, ?, ?): undefined\");\n  }",
    "Closure-164_testSupAndInfOfReturnTypesWithNumOfParams": "  public void testSupAndInfOfReturnTypesWithNumOfParams() {\n    FunctionType twoNumbers = new FunctionBuilder(registry)\n        .withParamsNode(registry.createParameters(NUMBER_TYPE, NUMBER_TYPE))\n        .withReturnType(BOOLEAN_TYPE).build();\n    FunctionType oneNumber = new FunctionBuilder(registry)\n        .withParamsNode(registry.createParameters(NUMBER_TYPE))\n        .withReturnType(BOOLEAN_TYPE).build();\n\n    assertLeastSupertype(\n        \"function (number, number): boolean\", twoNumbers, oneNumber);\n    assertGreatestSubtype(\n        \"function (number): boolean\", twoNumbers, oneNumber);\n  }",
    "Closure-166_testIssue785": "  public void testIssue785() {\n    inFunction(\"/** @param {string|{prop: (string|undefined)}} x */\" +\n               \"function f(x) {}\" +\n               \"var out = {};\" +\n               \"f(out);\");\n    assertEquals(\"{prop: (string|undefined)}\", getType(\"out\").toString());\n  }",
    "Closure-166_testRecordInference": "  public void testRecordInference() {\n    inFunction(\n        \"/** @param {{a: (boolean|undefined)}|{b: (string|undefined)}} x */\" +\n        \"function f(x) {}\" +\n        \"var out = {};\" +\n        \"f(out);\");\n    assertEquals(\"{a: (boolean|undefined), b: (string|undefined)}\",\n        getType(\"out\").toString());\n  }",
    "Closure-168_testIssue726": "  public void testIssue726() throws Exception {\n    testTypes(\n        \"/** @constructor */ function Foo() {}\" +\n        \"/** @param {number} x */ Foo.prototype.bar = function(x) {};\" +\n        \"/** @return {!Function} */ \" +\n        \"Foo.prototype.getDeferredBar = function() { \" +\n        \"  var self = this;\" +\n        \"  return function() {\" +\n        \"    self.bar(true);\" +\n        \"  };\" +\n        \"};\",\n        \"actual parameter 1 of Foo.prototype.bar does not match formal parameter\\n\" +\n        \"found   : boolean\\n\" +\n        \"required: number\");\n  }",
    "Closure-172_testIssue1024": "  public void testIssue1024() throws Exception {\n     testTypes(\n        \"/** @param {Object} a */\\n\" +\n        \"function f(a) {\\n\" +\n        \"  a.prototype = '__proto'\\n\" +\n        \"}\\n\" +\n        \"/** @param {Object} b\\n\" +\n        \" *  @return {!Object}\\n\" +\n        \" */\\n\" +\n        \"function g(b) {\\n\" +\n        \"  return b.prototype\\n\" +\n        \"}\\n\");\n     /* TODO(blickly): Make this warning go away.\n      * This is old behavior, but it doesn't make sense to warn about since\n      * both assignments are inferred.\n      */\n     testTypes(\n        \"/** @param {Object} a */\\n\" +\n        \"function f(a) {\\n\" +\n        \"  a.prototype = {foo:3};\\n\" +\n        \"}\\n\" +\n        \"/** @param {Object} b\\n\" +\n        \" */\\n\" +\n        \"function g(b) {\\n\" +\n        \"  b.prototype = function(){};\\n\" +\n        \"}\\n\",\n        \"assignment to property prototype of Object\\n\" +\n        \"found   : {foo: number}\\n\" +\n        \"required: function (): undefined\");\n  }",
    "Closure-176_testIssue1056": "  public void testIssue1056() throws Exception {\n    testTypes(\n        \"/** @type {Array} */ var x = null;\" +\n        \"x.push('hi');\",\n        \"No properties on this expression\\n\" +\n        \"found   : null\\n\" +\n        \"required: Object\");\n  }",
    "Codec-10_testEndMb": "    public void testEndMb() throws EncoderException {\n        String[][] data = {{\"mb\", \"M111111111\"}, {\"mbmb\", \"MPM1111111\"}};\n        this.checkEncodings(data);\n    }",
    "Codec-15_testHWRuleEx1": "    public void testHWRuleEx1() {\n        // From\n        // http://www.archives.gov/research_room/genealogy/census/soundex.html:\n        // Ashcraft is coded A-261 (A, 2 for the S, C ignored, 6 for the R, 1\n        // for the F). It is not coded A-226.\n        Assert.assertEquals(\"A261\", this.getStringEncoder().encode(\"Ashcraft\"));\n        Assert.assertEquals(\"A261\", this.getStringEncoder().encode(\"Ashcroft\"));\n        Assert.assertEquals(\"Y330\", this.getStringEncoder().encode(\"yehudit\"));\n        Assert.assertEquals(\"Y330\", this.getStringEncoder().encode(\"yhwdyt\"));\n    }",
    "Codec-17_testNewStringNullInput_CODEC229": "    public void testNewStringNullInput_CODEC229() {\n        Assert.assertNull(StringUtils.newStringUtf8(null));\n        Assert.assertNull(StringUtils.newStringIso8859_1(null));\n        Assert.assertNull(StringUtils.newStringUsAscii(null));\n        Assert.assertNull(StringUtils.newStringUtf16(null));\n        Assert.assertNull(StringUtils.newStringUtf16Be(null));\n        Assert.assertNull(StringUtils.newStringUtf16Le(null));\n    }",
    "Codec-18_testEqualsCS1": "    public void testEqualsCS1() {\n        Assert.assertFalse(StringUtils.equals(new StringBuilder(\"abc\"), null));\n        Assert.assertFalse(StringUtils.equals(null, new StringBuilder(\"abc\")));\n        Assert.assertTrue(StringUtils.equals(new StringBuilder(\"abc\"), new StringBuilder(\"abc\")));\n        Assert.assertFalse(StringUtils.equals(new StringBuilder(\"abc\"), new StringBuilder(\"abcd\")));\n        Assert.assertFalse(StringUtils.equals(new StringBuilder(\"abcd\"), new StringBuilder(\"abc\")));\n        Assert.assertFalse(StringUtils.equals(new StringBuilder(\"abc\"), new StringBuilder(\"ABC\")));\n    }",
    "Codec-18_testEqualsCS2": "    public void testEqualsCS2() {\n        Assert.assertTrue(StringUtils.equals(\"abc\", new StringBuilder(\"abc\")));\n        Assert.assertFalse(StringUtils.equals(new StringBuilder(\"abc\"), \"abcd\"));\n        Assert.assertFalse(StringUtils.equals(\"abcd\", new StringBuilder(\"abc\")));\n        Assert.assertFalse(StringUtils.equals(new StringBuilder(\"abc\"), \"ABC\"));\n    }",
    "Codec-2_testBase64EmptyInputStream": "    public void testBase64EmptyInputStream() throws Exception {\n        byte[] emptyEncoded = new byte[0];\n        byte[] emptyDecoded = new byte[0];\n        testByteByByte(emptyEncoded, emptyDecoded, 76, CRLF);\n        testByChunk(emptyEncoded, emptyDecoded, 76, CRLF);\n    }",
    "Codec-2_testBase64EmptyOutputStream": "    public void testBase64EmptyOutputStream() throws Exception {\n        byte[] emptyEncoded = new byte[0];\n        byte[] emptyDecoded = new byte[0];\n        testByteByByte(emptyEncoded, emptyDecoded, 76, CRLF);\n        testByChunk(emptyEncoded, emptyDecoded, 76, CRLF);\n    }    ",
    "Codec-3_testDoubleMetaphoneAlternate": "    public void testDoubleMetaphoneAlternate() {\n        String value = null;\n        for (int i = 0; i < TEST_DATA.length; i++) {\n            value = TEST_DATA[i][0];\n            assertEquals(\"Test [\" + i + \"]=\" + value, TEST_DATA[i][2], doubleMetaphone.doubleMetaphone(value, true));\n        }\n    }",
    "Codec-4_testBinaryEncoder": "    public void testBinaryEncoder() throws EncoderException {\n        BinaryEncoder enc = new Base64();\n        for (int i = 0; i < STRINGS.length; i++) {\n            if (STRINGS[i] != null) {\n                byte[] base64 = utf8(STRINGS[i]);\n                byte[] binary = BYTES[i];\n                boolean b = Arrays.equals(base64, enc.encode(binary));\n                assertTrue(\"BinaryEncoder test-\" + i, b);\n            }\n        }\n    }",
    "Codec-4_testEncoder": "    public void testEncoder() throws EncoderException {\n        Encoder enc = new Base64();\n        for (int i = 0; i < STRINGS.length; i++) {\n            if (STRINGS[i] != null) {\n                byte[] base64 = utf8(STRINGS[i]);\n                byte[] binary = BYTES[i];\n                boolean b = Arrays.equals(base64, (byte[]) enc.encode(binary));\n                assertTrue(\"Encoder test-\" + i, b);\n            }\n        }\n    }",
    "Codec-5_testCodec98NPE": "    public void testCodec98NPE() throws Exception {\n        byte[] codec98 = StringUtils.getBytesUtf8(Base64TestData.CODEC_98_NPE);\n        byte[] codec98_1024 = new byte[1024];\n        System.arraycopy(codec98, 0, codec98_1024, 0, codec98.length);\n        ByteArrayOutputStream data = new ByteArrayOutputStream(1024);\n        Base64OutputStream stream = new Base64OutputStream(data, false);\n        stream.write(codec98_1024, 0, 1024);\n        stream.close();\n\n        byte[] decodedBytes = data.toByteArray();\n        String decoded = StringUtils.newStringUtf8(decodedBytes);\n        assertEquals(\n            \"codec-98 NPE Base64OutputStream\", Base64TestData.CODEC_98_NPE_DECODED, decoded\n        );\n    }",
    "Codec-6_testCodec101": "    public void testCodec101() throws Exception {\n        byte[] codec101 = StringUtils.getBytesUtf8(Base64TestData.CODEC_101_MULTIPLE_OF_3);\n        ByteArrayInputStream bais = new ByteArrayInputStream(codec101);\n        Base64InputStream in = new Base64InputStream(bais);\n        byte[] result = new byte[8192];\n        int c = in.read(result);\n        assertTrue(\"Codec101: First read successful [c=\" + c + \"]\", c > 0);\n\n        c = in.read(result);\n        assertTrue(\"Codec101: Second read should report end-of-stream [c=\" + c + \"]\", c < 0);\n    }",
    "Codec-7_testByteToStringVariations": "    public void testByteToStringVariations() throws DecoderException {\n        Base64 base64 = new Base64(0);\n        byte[] b1 = StringUtils.getBytesUtf8(\"Hello World\");\n        byte[] b2 = new byte[0];\n        byte[] b3 = null;\n        byte[] b4 = Hex.decodeHex(\"2bf7cc2701fe4397b49ebeed5acc7090\".toCharArray());  // for url-safe tests\n\n        assertEquals(\"byteToString Hello World\", \"SGVsbG8gV29ybGQ=\", base64.encodeToString(b1));\n        assertEquals(\"byteToString static Hello World\", \"SGVsbG8gV29ybGQ=\", Base64.encodeBase64String(b1));\n        assertEquals(\"byteToString \\\"\\\"\", \"\", base64.encodeToString(b2));\n        assertEquals(\"byteToString static \\\"\\\"\", \"\", Base64.encodeBase64String(b2));\n        assertEquals(\"byteToString null\", null, base64.encodeToString(b3));\n        assertEquals(\"byteToString static null\", null, Base64.encodeBase64String(b3));\n        assertEquals(\"byteToString UUID\", \"K/fMJwH+Q5e0nr7tWsxwkA==\", base64.encodeToString(b4));\n        assertEquals(\"byteToString static UUID\", \"K/fMJwH+Q5e0nr7tWsxwkA==\", Base64.encodeBase64String(b4));\n        assertEquals(\"byteToString static-url-safe UUID\", \"K_fMJwH-Q5e0nr7tWsxwkA\", Base64.encodeBase64URLSafeString(b4));\n    }",
    "Codec-7_testRfc4648Section10Encode": "    public void testRfc4648Section10Encode() {\n        assertEquals(\"\", Base64.encodeBase64String(StringUtils.getBytesUtf8(\"\")));\n        assertEquals(\"Zg==\", Base64.encodeBase64String(StringUtils.getBytesUtf8(\"f\")));\n        assertEquals(\"Zm8=\", Base64.encodeBase64String(StringUtils.getBytesUtf8(\"fo\")));\n        assertEquals(\"Zm9v\", Base64.encodeBase64String(StringUtils.getBytesUtf8(\"foo\")));\n        assertEquals(\"Zm9vYg==\", Base64.encodeBase64String(StringUtils.getBytesUtf8(\"foob\")));\n        assertEquals(\"Zm9vYmE=\", Base64.encodeBase64String(StringUtils.getBytesUtf8(\"fooba\")));\n        assertEquals(\"Zm9vYmFy\", Base64.encodeBase64String(StringUtils.getBytesUtf8(\"foobar\")));\n    }",
    "Codec-9_testCodec112": "    public void testCodec112() { // size calculation assumes always chunked\n        byte[] in = new byte[] {0};\n        byte[] out=Base64.encodeBase64(in);\n        Base64.encodeBase64(in, false, false, out.length);\n    }",
    "Collections-26_testEqualsAfterSerializationOfDerivedClass": "    public void testEqualsAfterSerializationOfDerivedClass() throws IOException, ClassNotFoundException\n    {\n        final DerivedMultiKey<?> mk = new DerivedMultiKey<String>(\"A\", \"B\");\n\n        // serialize\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final ObjectOutputStream out = new ObjectOutputStream(baos);\n        out.writeObject(mk);\n        out.close();\n\n        // deserialize\n        final ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n        final ObjectInputStream in = new ObjectInputStream(bais);\n        final DerivedMultiKey<?> mk2 = (DerivedMultiKey<?>)in.readObject();\n        in.close();\n\n        assertEquals(mk.hashCode(), mk2.hashCode());\n    }",
    "Compress-10_testReadWinZipArchive": "    public void testReadWinZipArchive() throws IOException, URISyntaxException {\n        URL zip = getClass().getResource(\"/utf8-winzip-test.zip\");\n        File archive = new File(new URI(zip.toString()));\n        ZipFile zf = null;\n        try {\n            zf = new ZipFile(archive, null, true);\n            assertCanRead(zf, ASCII_TXT);\n            assertCanRead(zf, EURO_FOR_DOLLAR_TXT);\n            assertCanRead(zf, OIL_BARREL_TXT);\n        } finally {\n            ZipFile.closeQuietly(zf);\n        }\n    }",
    "Compress-11_shortTextFilesAreNoTARs": "    public void shortTextFilesAreNoTARs() throws Exception {\n        try {\n            new ArchiveStreamFactory()\n                .createArchiveInputStream(new ByteArrayInputStream(\"This certainly is not a tar archive, really, no kidding\".getBytes()));\n            fail(\"created an input stream for a non-archive\");\n        } catch (ArchiveException ae) {\n            assertTrue(ae.getMessage().startsWith(\"No Archiver found\"));\n        }\n    }",
    "Compress-12_testCOMPRESS178": "    public void testCOMPRESS178() throws Exception {\n        final File input = getFile(\"COMPRESS-178.tar\");\n        final InputStream is = new FileInputStream(input);\n        final ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(\"tar\", is);\n        try {\n            in.getNextEntry();\n            fail(\"Expected IOException\");\n        } catch (IOException e) {\n            Throwable t = e.getCause();\n            assertTrue(\"Expected cause = IllegalArgumentException\", t instanceof IllegalArgumentException);\n        }\n        in.close();\n    }",
    "Compress-13_testWinzipBackSlashWorkaround": "    public void testWinzipBackSlashWorkaround() throws Exception {\n        URL zip = getClass().getResource(\"/test-winzip.zip\");\n        File archive = new File(new URI(zip.toString()));\n        zf = new ZipFile(archive);\n        assertNull(zf.getEntry(\"\\u00e4\\\\\\u00fc.txt\"));\n        assertNotNull(zf.getEntry(\"\\u00e4/\\u00fc.txt\"));\n    }",
    "Compress-13_winzipBackSlashWorkaround": "    public void winzipBackSlashWorkaround() throws Exception {\n        URL zip = getClass().getResource(\"/test-winzip.zip\");\n        ZipArchiveInputStream in = null;\n        try {\n            in = new ZipArchiveInputStream(new FileInputStream(new File(new URI(zip.toString()))));\n            ZipArchiveEntry zae = in.getNextZipEntry();\n            zae = in.getNextZipEntry();\n            zae = in.getNextZipEntry();\n            assertEquals(\"\\u00e4/\", zae.getName());\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }",
    "Compress-14_workaroundForBrokenTimeHeader": "    public void workaroundForBrokenTimeHeader() throws Exception {\n        URL tar = getClass().getResource(\"/simple-aix-native-tar.tar\");\n        TarArchiveInputStream in = null;\n        try {\n            in = new TarArchiveInputStream(new FileInputStream(new File(new URI(tar.toString()))));\n            TarArchiveEntry tae = in.getNextTarEntry();\n            tae = in.getNextTarEntry();\n            assertEquals(\"sample/link-to-txt-file.lnk\", tae.getName());\n            assertEquals(new Date(0), tae.getLastModifiedDate());\n            assertTrue(tae.isSymbolicLink());\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }        ",
    "Compress-15_testNullCommentEqualsEmptyComment": "    public void testNullCommentEqualsEmptyComment() {\n        ZipArchiveEntry entry1 = new ZipArchiveEntry(\"foo\");\n        ZipArchiveEntry entry2 = new ZipArchiveEntry(\"foo\");\n        ZipArchiveEntry entry3 = new ZipArchiveEntry(\"foo\");\n        entry1.setComment(null);\n        entry2.setComment(\"\");\n        entry3.setComment(\"bar\");\n        assertEquals(entry1, entry2);\n        assertFalse(entry1.equals(entry3));\n        assertFalse(entry2.equals(entry3));\n    }",
    "Compress-16_aiffFilesAreNoTARs": "    public void aiffFilesAreNoTARs() throws Exception {\n        InputStream is = null;\n        try {\n            is = new BufferedInputStream(new FileInputStream(\"src/test/resources/testAIFF.aif\"));\n            new ArchiveStreamFactory().createArchiveInputStream(is);\n            fail(\"created an input stream for a non-archive\");\n        } catch (ArchiveException ae) {\n            assertTrue(ae.getMessage().startsWith(\"No Archiver found\"));\n        } finally {\n            if (is != null) {\n                is.close();\n            }\n        }\n    }",
    "Compress-17_testCompress197": "    public void testCompress197() throws Exception {\n        TarArchiveInputStream tar = getTestStream(\"/COMPRESS-197.tar\");\n        try {\n            TarArchiveEntry entry = tar.getNextTarEntry();\n            while (entry != null) {\n                entry = tar.getNextTarEntry();\n            }\n        } catch (IOException e) {\n            fail(\"COMPRESS-197: \" + e.getMessage());\n        } finally {\n            tar.close();\n        }\n    }",
    "Compress-18_testWriteNonAsciiDirectoryNamePosixMode": "    public void testWriteNonAsciiDirectoryNamePosixMode() throws Exception {\n        String n = \"f\\u00f6\\u00f6/\";\n        TarArchiveEntry t = new TarArchiveEntry(n);\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        TarArchiveOutputStream tos = new TarArchiveOutputStream(bos);\n        tos.setAddPaxHeadersForNonAsciiNames(true);\n        tos.putArchiveEntry(t);\n        tos.closeArchiveEntry();\n        tos.close();\n        byte[] data = bos.toByteArray();\n        TarArchiveInputStream tin =\n            new TarArchiveInputStream(new ByteArrayInputStream(data));\n        TarArchiveEntry e = tin.getNextTarEntry();\n        assertEquals(n, e.getName());\n        assertTrue(e.isDirectory());\n        tin.close();\n    }",
    "Compress-19_testExcessDataInZip64ExtraField": "    public void testExcessDataInZip64ExtraField() throws Exception {\n        File archive = getFile(\"COMPRESS-228.zip\");\n        zf = new ZipFile(archive);\n        // actually, if we get here, the test already has passed\n\n        ZipArchiveEntry ze = zf.getEntry(\"src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\");\n        assertEquals(26101, ze.getSize());\n    }",
    "Compress-1_testCpioUnarchive": "    public void testCpioUnarchive() throws Exception {\n        final File output = new File(dir, \"bla.cpio\");\n        {\n            final File file1 = getFile(\"test1.xml\");\n            final File file2 = getFile(\"test2.xml\");\n\n            final OutputStream out = new FileOutputStream(output);\n            final ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream(\"cpio\", out);\n            os.putArchiveEntry(new CpioArchiveEntry(\"test1.xml\", file1.length()));\n            IOUtils.copy(new FileInputStream(file1), os);\n            os.closeArchiveEntry();\n\n            os.putArchiveEntry(new CpioArchiveEntry(\"test2.xml\", file2.length()));\n            IOUtils.copy(new FileInputStream(file2), os);\n            os.closeArchiveEntry();\n\n            os.close();\n            out.close();\n        }\n\n        // Unarchive Operation\n        final File input = output;\n        final InputStream is = new FileInputStream(input);\n        final ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(\"cpio\", is);\n\n\n        Map result = new HashMap();\n        ArchiveEntry entry = null;\n        while ((entry = in.getNextEntry()) != null) {\n            File target = new File(dir, entry.getName());\n            final OutputStream out = new FileOutputStream(target);\n            IOUtils.copy(in, out);\n            out.close();\n            result.put(entry.getName(), target);\n        }\n        in.close();\n\n        int lineSepLength = System.getProperty(\"line.separator\").length();\n\n        File t = (File)result.get(\"test1.xml\");\n        assertTrue(\"Expected \" + t.getAbsolutePath() + \" to exist\", t.exists());\n        assertEquals(\"length of \" + t.getAbsolutePath(),\n                     72 + 4 * lineSepLength, t.length());\n\n        t = (File)result.get(\"test2.xml\");\n        assertTrue(\"Expected \" + t.getAbsolutePath() + \" to exist\", t.exists());\n        assertEquals(\"length of \" + t.getAbsolutePath(),\n                     73 + 5 * lineSepLength, t.length());\n    }",
    "Compress-21_testEightEmptyFiles": "    public void testEightEmptyFiles() throws Exception {\n        testCompress252(8, 0);\n    }",
    "Compress-21_testEightFilesSomeNotEmpty": "    public void testEightFilesSomeNotEmpty() throws Exception {\n        testCompress252(8, 2);\n    }",
    "Compress-21_testNineEmptyFiles": "    public void testNineEmptyFiles() throws Exception {\n        testCompress252(9, 0);\n    }",
    "Compress-21_testNineFilesSomeNotEmpty": "    public void testNineFilesSomeNotEmpty() throws Exception {\n        testCompress252(9, 2);\n    }",
    "Compress-21_testSevenEmptyFiles": "    public void testSevenEmptyFiles() throws Exception {\n        testCompress252(7, 0);\n    }",
    "Compress-21_testSevenFilesSomeNotEmpty": "    public void testSevenFilesSomeNotEmpty() throws Exception {\n        testCompress252(7, 2);\n    }",
    "Compress-21_testSixEmptyFiles": "    public void testSixEmptyFiles() throws Exception {\n        testCompress252(6, 0);\n    }",
    "Compress-21_testSixFilesSomeNotEmpty": "    public void testSixFilesSomeNotEmpty() throws Exception {\n        testCompress252(6, 2);\n    }",
    "Compress-23_testCompressedHeaderWithNonDefaultDictionarySize": "    public void testCompressedHeaderWithNonDefaultDictionarySize() throws Exception {\n        SevenZFile sevenZFile = new SevenZFile(getFile(\"COMPRESS-256.7z\"));\n        try {\n            int count = 0;\n            while (sevenZFile.getNextEntry() != null) {\n                count++;\n            }\n            assertEquals(446, count);\n        } finally {\n            sevenZFile.close();\n        }\n    }",
    "Compress-24_testParseOctal": "    public void testParseOctal() throws Exception{\n        long value; \n        byte [] buffer;\n        final long MAX_OCTAL  = 077777777777L; // Allowed 11 digits\n        final long MAX_OCTAL_OVERFLOW  = 0777777777777L; // in fact 12 for some implementations\n        final String maxOctal = \"777777777777\"; // Maximum valid octal\n        buffer = maxOctal.getBytes(CharsetNames.UTF_8);\n        value = TarUtils.parseOctal(buffer,0, buffer.length);\n        assertEquals(MAX_OCTAL_OVERFLOW, value);\n        buffer[buffer.length - 1] = ' ';\n        value = TarUtils.parseOctal(buffer,0, buffer.length);\n        assertEquals(MAX_OCTAL, value);\n        buffer[buffer.length-1]=0;\n        value = TarUtils.parseOctal(buffer,0, buffer.length);\n        assertEquals(MAX_OCTAL, value);\n        buffer=new byte[]{0,0};\n        value = TarUtils.parseOctal(buffer,0, buffer.length);\n        assertEquals(0, value);\n        buffer=new byte[]{0,' '};\n        value = TarUtils.parseOctal(buffer,0, buffer.length);\n        assertEquals(0, value);\n    }",
    "Compress-25_testReadingOfFirstStoredEntry": "    public void testReadingOfFirstStoredEntry() throws Exception {\n        ZipArchiveInputStream in = new ZipArchiveInputStream(new FileInputStream(getFile(\"COMPRESS-264.zip\")));\n        \n        try {\n            ZipArchiveEntry ze = in.getNextZipEntry();\n            assertEquals(5, ze.getSize());\n            assertArrayEquals(new byte[] {'d', 'a', 't', 'a', '\\n'},\n                              IOUtils.toByteArray(in));\n        } finally {\n            in.close();\n        }\n    }",
    "Compress-26_skipUsingRead": "    public void skipUsingRead() throws Exception {\n        skip(new StreamWrapper() {\n                public InputStream wrap(InputStream toWrap) {\n                    return new FilterInputStream(toWrap) {\n                        public long skip(long s) {\n                            return 0;\n                        }\n                    };\n                }\n            });\n    }",
    "Compress-26_skipUsingSkipAndRead": "    public void skipUsingSkipAndRead() throws Exception {\n        skip(new StreamWrapper() {\n                public InputStream wrap(final InputStream toWrap) {\n                    return new FilterInputStream(toWrap) {\n                        boolean skipped;\n                        public long skip(long s) throws IOException {\n                            if (!skipped) {\n                                toWrap.skip(5);\n                                skipped = true;\n                                return 5;\n                            }\n                            return 0;\n                        }\n                    };\n                }\n            });\n    }",
    "Compress-27_testParseOctal": "    public void testParseOctal() throws Exception{\n        long value; \n        byte [] buffer;\n        final long MAX_OCTAL  = 077777777777L; // Allowed 11 digits\n        final long MAX_OCTAL_OVERFLOW  = 0777777777777L; // in fact 12 for some implementations\n        final String maxOctal = \"777777777777\"; // Maximum valid octal\n        buffer = maxOctal.getBytes(CharsetNames.UTF_8);\n        value = TarUtils.parseOctal(buffer,0, buffer.length);\n        assertEquals(MAX_OCTAL_OVERFLOW, value);\n        buffer[buffer.length - 1] = ' ';\n        value = TarUtils.parseOctal(buffer,0, buffer.length);\n        assertEquals(MAX_OCTAL, value);\n        buffer[buffer.length-1]=0;\n        value = TarUtils.parseOctal(buffer,0, buffer.length);\n        assertEquals(MAX_OCTAL, value);\n        buffer=new byte[]{0,0};\n        value = TarUtils.parseOctal(buffer,0, buffer.length);\n        assertEquals(0, value);\n        buffer=new byte[]{0,' '};\n        value = TarUtils.parseOctal(buffer,0, buffer.length);\n        assertEquals(0, value);\n        buffer=new byte[]{' ',0};\n        value = TarUtils.parseOctal(buffer,0, buffer.length);\n        assertEquals(0, value);\n    }",
    "Compress-28_shouldThrowAnExceptionOnTruncatedEntries": "    public void shouldThrowAnExceptionOnTruncatedEntries() throws Exception {\n        File dir = mkdir(\"COMPRESS-279\");\n        TarArchiveInputStream is = getTestStream(\"/COMPRESS-279.tar\");\n        FileOutputStream out = null;\n        try {\n            TarArchiveEntry entry = is.getNextTarEntry();\n            int count = 0;\n            while (entry != null) {\n                out = new FileOutputStream(new File(dir, String.valueOf(count)));\n                IOUtils.copy(is, out);\n                out.close();\n                out = null;\n                count++;\n                entry = is.getNextTarEntry();\n            }\n        } finally {\n            is.close();\n            if (out != null) {\n                out.close();\n            }\n        }\n    }",
    "Compress-30_readOfLength0ShouldReturn0": "    public void readOfLength0ShouldReturn0() throws Exception {\n        // Create a big random piece of data\n        byte[] rawData = new byte[1048576];\n        for (int i=0; i < rawData.length; ++i) {\n            rawData[i] = (byte) Math.floor(Math.random()*256);\n        }\n\n        // Compress it\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        BZip2CompressorOutputStream bzipOut = new BZip2CompressorOutputStream(baos);\n        bzipOut.write(rawData);\n        bzipOut.flush();\n        bzipOut.close();\n        baos.flush();\n        baos.close();\n\n        // Try to read it back in\n        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n        BZip2CompressorInputStream bzipIn = new BZip2CompressorInputStream(bais);\n        byte[] buffer = new byte[1024];\n        Assert.assertEquals(1024, bzipIn.read(buffer, 0, 1024));\n        Assert.assertEquals(0, bzipIn.read(buffer, 1024, 0));\n        Assert.assertEquals(1024, bzipIn.read(buffer, 0, 1024));\n        bzipIn.close();\n    }",
    "Compress-31_testCOMPRESS178": "    public void testCOMPRESS178() throws Exception {\n        final File input = getFile(\"COMPRESS-178.tar\");\n        final InputStream is = new FileInputStream(input);\n        final ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(\"tar\", is);\n        try {\n            in.getNextEntry();\n            fail(\"Expected IOException\");\n        } catch (IOException e) {\n            Throwable t = e.getCause();\n            assertTrue(\"Expected cause = IllegalArgumentException\", t instanceof IllegalArgumentException);\n        }\n        in.close();\n    }",
    "Compress-31_testParseOctalInvalid": "    public void testParseOctalInvalid() throws Exception{\n        byte [] buffer;\n        buffer=new byte[0]; // empty byte array\n        try {\n            TarUtils.parseOctal(buffer,0, buffer.length);\n            fail(\"Expected IllegalArgumentException - should be at least 2 bytes long\");\n        } catch (IllegalArgumentException expected) {\n        }\n        buffer=new byte[]{0}; // 1-byte array\n        try {\n            TarUtils.parseOctal(buffer,0, buffer.length);\n            fail(\"Expected IllegalArgumentException - should be at least 2 bytes long\");\n        } catch (IllegalArgumentException expected) {\n        }\n        buffer = \"abcdef \".getBytes(CharsetNames.UTF_8); // Invalid input\n        try {\n            TarUtils.parseOctal(buffer,0, buffer.length);\n            fail(\"Expected IllegalArgumentException\");\n        } catch (IllegalArgumentException expected) {\n        }\n        buffer = \" 0 07 \".getBytes(CharsetNames.UTF_8); // Invalid - embedded space\n        try {\n            TarUtils.parseOctal(buffer,0, buffer.length);\n            fail(\"Expected IllegalArgumentException - embedded space\");\n        } catch (IllegalArgumentException expected) {\n        }\n        buffer = \" 0\\00007 \".getBytes(CharsetNames.UTF_8); // Invalid - embedded NUL\n        try {\n            TarUtils.parseOctal(buffer,0, buffer.length);\n            fail(\"Expected IllegalArgumentException - embedded NUL\");\n        } catch (IllegalArgumentException expected) {\n        }\n    }",
    "Compress-32_shouldReadBigGid": "    public void shouldReadBigGid() throws Exception {\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        TarArchiveOutputStream tos = new TarArchiveOutputStream(bos);\n        tos.setBigNumberMode(TarArchiveOutputStream.BIGNUMBER_POSIX);\n        TarArchiveEntry t = new TarArchiveEntry(\"name\");\n        t.setGroupId(4294967294l);\n        t.setSize(1);\n        tos.putArchiveEntry(t);\n        tos.write(30);\n        tos.closeArchiveEntry();\n        tos.close();\n        byte[] data = bos.toByteArray();\n        ByteArrayInputStream bis = new ByteArrayInputStream(data);\n        TarArchiveInputStream tis =\n            new TarArchiveInputStream(bis);\n        t = tis.getNextTarEntry();\n        assertEquals(4294967294l, t.getLongGroupId());\n        tis.close();\n    }",
    "Compress-35_testCOMPRESS335": "    public void testCOMPRESS335() throws Exception {\n        final ArchiveInputStream tar = getStreamFor(\"COMPRESS-335.tar\");\n        assertNotNull(tar);\n        assertTrue(tar instanceof TarArchiveInputStream);\n    }",
    "Compress-36_readEntriesOfSize0": "    public void readEntriesOfSize0() throws IOException {\n        final SevenZFile sevenZFile = new SevenZFile(getFile(\"COMPRESS-348.7z\"));\n        try {\n            int entries = 0;\n            SevenZArchiveEntry entry = sevenZFile.getNextEntry();\n            while (entry != null) {\n                entries++;\n                int b = sevenZFile.read();\n                if (\"2.txt\".equals(entry.getName()) || \"5.txt\".equals(entry.getName())) {\n                    assertEquals(-1, b);\n                } else {\n                    assertNotEquals(-1, b);\n                }\n                entry = sevenZFile.getNextEntry();\n            }\n            assertEquals(5, entries);\n        } finally {\n            sevenZFile.close();\n        }\n    }",
    "Compress-37_survivesBlankLinesInPaxHeader": "    public void survivesBlankLinesInPaxHeader() throws Exception {\n        final TarArchiveInputStream is = getTestStream(\"/COMPRESS-355.tar\");\n        try {\n            final TarArchiveEntry entry = is.getNextTarEntry();\n            assertEquals(\"package/package.json\", entry.getName());\n            assertNull(is.getNextTarEntry());\n        } finally {\n            is.close();\n        }\n    }",
    "Compress-38_survivesPaxHeaderWithNameEndingInSlash": "    public void survivesPaxHeaderWithNameEndingInSlash() throws Exception {\n        final TarArchiveInputStream is = getTestStream(\"/COMPRESS-356.tar\");\n        try {\n            final TarArchiveEntry entry = is.getNextTarEntry();\n            assertEquals(\"package/package.json\", entry.getName());\n            assertNull(is.getNextTarEntry());\n        } finally {\n            is.close();\n        }\n    }",
    "Compress-40_bigEndianWithOverflow": "    public void bigEndianWithOverflow() throws Exception {\n        ByteArrayInputStream in = new ByteArrayInputStream(new byte[] {\n                87, // 01010111\n                45, // 00101101\n                66, // 01000010\n                15, // 00001111\n                90, // 01011010\n                29, // 00011101\n                88, // 01011000\n                61, // 00111101\n                33, // 00100001\n                74  // 01001010\n            });\n        BitInputStream bin = new BitInputStream(in, ByteOrder.BIG_ENDIAN);\n        assertEquals(10, // 01010\n                     bin.readBits(5));\n        assertEquals(8274274654740644818l, //111-00101101-01000010-00001111-01011010-00011101-01011000-00111101-0010\n                     bin.readBits(63));\n        assertEquals(330, // 0001-01001010\n                     bin.readBits(12));\n        assertEquals(-1 , bin.readBits(1));\n    }",
    "Compress-40_littleEndianWithOverflow": "    public void littleEndianWithOverflow() throws Exception {\n        ByteArrayInputStream in = new ByteArrayInputStream(new byte[] {\n                87, // 01010111\n                45, // 00101101\n                66, // 01000010\n                15, // 00001111\n                90, // 01011010\n                29, // 00011101\n                88, // 01011000\n                61, // 00111101\n                33, // 00100001\n                74  // 01001010\n            });\n        BitInputStream bin = new BitInputStream(in, ByteOrder.LITTLE_ENDIAN);\n        assertEquals(23, // 10111\n                     bin.readBits(5));\n        assertEquals(714595605644185962l, // 0001-00111101-01011000-00011101-01011010-00001111-01000010-00101101-010\n                     bin.readBits(63));\n        assertEquals(1186, // 01001010-0010\n                     bin.readBits(12));\n        assertEquals(-1 , bin.readBits(1));\n    }",
    "Compress-41_testListAllFilesWithNestedArchive": "    public void testListAllFilesWithNestedArchive() throws Exception {\n        final File input = getFile(\"OSX_ArchiveWithNestedArchive.zip\");\n\n        final List<String> results = new ArrayList<>();\n        final List<ZipException> expectedExceptions = new ArrayList<>();\n\n        final InputStream is = new FileInputStream(input);\n        ArchiveInputStream in = null;\n        try {\n            in = new ArchiveStreamFactory().createArchiveInputStream(\"zip\", is);\n\n            ZipArchiveEntry entry = null;\n            while ((entry = (ZipArchiveEntry) in.getNextEntry()) != null) {\n                results.add(entry.getName());\n\n                final ArchiveInputStream nestedIn = new ArchiveStreamFactory().createArchiveInputStream(\"zip\", in);\n                try {\n                    ZipArchiveEntry nestedEntry = null;\n                    while ((nestedEntry = (ZipArchiveEntry) nestedIn.getNextEntry()) != null) {\n                        results.add(nestedEntry.getName());\n                    }\n                } catch (ZipException ex) {\n                    // expected since you cannot create a final ArchiveInputStream from test3.xml\n                    expectedExceptions.add(ex);\n                }\n                // nested stream must not be closed here\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n        is.close();\n\n        assertTrue(results.contains(\"NestedArchiv.zip\"));\n        assertTrue(results.contains(\"test1.xml\"));\n        assertTrue(results.contains(\"test2.xml\"));\n        assertTrue(results.contains(\"test3.xml\"));\n        assertEquals(1, expectedExceptions.size());\n    }",
    "Compress-41_testThrowOnInvalidEntry": "    public void testThrowOnInvalidEntry() throws Exception {\n        final InputStream is = ZipArchiveInputStreamTest.class\n                .getResourceAsStream(\"/invalid-zip.zip\");\n        final ZipArchiveInputStream zip = new ZipArchiveInputStream(is);\n\n        try {\n            zip.getNextZipEntry();\n            fail(\"IOException expected\");\n        } catch (ZipException expected) {\n            assertTrue(expected.getMessage().contains(\"Unexpected record signature\"));\n        } finally {\n            zip.close();\n        }\n    }",
    "Compress-44_testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne": "    public void testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne() {\n\n        ChecksumCalculatingInputStream checksumCalculatingInputStream = new ChecksumCalculatingInputStream(null,null);\n\n\n    }",
    "Compress-44_testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionThree": "    public void testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionThree() {\n\n        ChecksumCalculatingInputStream checksumCalculatingInputStream = new ChecksumCalculatingInputStream(new CRC32(),null);\n\n    }",
    "Compress-44_testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionTwo": "    public void testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionTwo() {\n\n        ChecksumCalculatingInputStream checksumCalculatingInputStream = new ChecksumCalculatingInputStream(null,new ByteArrayInputStream(new byte[1]));\n\n\n    }",
    "Compress-45_testRoundTripOctalOrBinary8": "    public void testRoundTripOctalOrBinary8() {\n        testRoundTripOctalOrBinary(8);\n    }",
    "Compress-46_testGettersSetters": "    public void testGettersSetters() {\n        // X5455 is concerned with time, so let's\n        // get a timestamp to play with (Jan 1st, 2000).\n        final Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(\"UTC\"));\n        cal.set(Calendar.YEAR, 2000);\n        cal.set(Calendar.MONTH, Calendar.JANUARY);\n        cal.set(Calendar.DATE, 1);\n        cal.set(Calendar.HOUR_OF_DAY, 0);\n        cal.set(Calendar.MINUTE, 0);\n        cal.set(Calendar.SECOND, 0);\n        cal.set(Calendar.MILLISECOND, 0);\n        final long timeMillis = cal.getTimeInMillis();\n        final ZipLong time = new ZipLong(timeMillis / 1000);\n\n        // set too big\n        try {\n            // Java time is 1000 x larger (milliseconds).\n            xf.setModifyJavaTime(new Date(1000L * (MAX_TIME_SECONDS.getValue() + 1L)));\n            fail(\"Time too big for 32 bits!\");\n        } catch (final IllegalArgumentException iae) {\n            // All is good.\n        }\n\n        // get/set modify time\n        xf.setModifyTime(time);\n        assertEquals(time, xf.getModifyTime());\n        Date xfModifyJavaTime = xf.getModifyJavaTime();\n        assertEquals(timeMillis, xfModifyJavaTime.getTime());\n        xf.setModifyJavaTime(new Date(timeMillis));\n        assertEquals(time, xf.getModifyTime());\n        assertEquals(timeMillis, xf.getModifyJavaTime().getTime());\n        // Make sure milliseconds get zeroed out:\n        xf.setModifyJavaTime(new Date(timeMillis + 123));\n        assertEquals(time, xf.getModifyTime());\n        assertEquals(timeMillis, xf.getModifyJavaTime().getTime());\n        // Null\n        xf.setModifyTime(null);\n        assertNull(xf.getModifyJavaTime());\n        xf.setModifyJavaTime(null);\n        assertNull(xf.getModifyTime());\n\n        // get/set access time\n        xf.setAccessTime(time);\n        assertEquals(time, xf.getAccessTime());\n        assertEquals(timeMillis, xf.getAccessJavaTime().getTime());\n        xf.setAccessJavaTime(new Date(timeMillis));\n        assertEquals(time, xf.getAccessTime());\n        assertEquals(timeMillis, xf.getAccessJavaTime().getTime());\n        // Make sure milliseconds get zeroed out:\n        xf.setAccessJavaTime(new Date(timeMillis + 123));\n        assertEquals(time, xf.getAccessTime());\n        assertEquals(timeMillis, xf.getAccessJavaTime().getTime());\n        // Null\n        xf.setAccessTime(null);\n        assertNull(xf.getAccessJavaTime());\n        xf.setAccessJavaTime(null);\n        assertNull(xf.getAccessTime());\n\n        // get/set create time\n        xf.setCreateTime(time);\n        assertEquals(time, xf.getCreateTime());\n        assertEquals(timeMillis, xf.getCreateJavaTime().getTime());\n        xf.setCreateJavaTime(new Date(timeMillis));\n        assertEquals(time, xf.getCreateTime());\n        assertEquals(timeMillis, xf.getCreateJavaTime().getTime());\n        // Make sure milliseconds get zeroed out:\n        xf.setCreateJavaTime(new Date(timeMillis + 123));\n        assertEquals(time, xf.getCreateTime());\n        assertEquals(timeMillis, xf.getCreateJavaTime().getTime());\n        // Null\n        xf.setCreateTime(null);\n        assertNull(xf.getCreateJavaTime());\n        xf.setCreateJavaTime(null);\n        assertNull(xf.getCreateTime());\n\n\n        // initialize for flags\n        xf.setModifyTime(time);\n        xf.setAccessTime(time);\n        xf.setCreateTime(time);\n\n        // get/set flags: 000\n        xf.setFlags((byte) 0);\n        assertEquals(0, xf.getFlags());\n        assertFalse(xf.isBit0_modifyTimePresent());\n        assertFalse(xf.isBit1_accessTimePresent());\n        assertFalse(xf.isBit2_createTimePresent());\n        // Local length=1, Central length=1 (flags only!)\n        assertEquals(1, xf.getLocalFileDataLength().getValue());\n        assertEquals(1, xf.getCentralDirectoryLength().getValue());\n\n        // get/set flags: 001\n        xf.setFlags((byte) 1);\n        assertEquals(1, xf.getFlags());\n        assertTrue(xf.isBit0_modifyTimePresent());\n        assertFalse(xf.isBit1_accessTimePresent());\n        assertFalse(xf.isBit2_createTimePresent());\n        // Local length=5, Central length=5 (flags + mod)\n        assertEquals(5, xf.getLocalFileDataLength().getValue());\n        assertEquals(5, xf.getCentralDirectoryLength().getValue());\n\n        // get/set flags: 010\n        xf.setFlags((byte) 2);\n        assertEquals(2, xf.getFlags());\n        assertFalse(xf.isBit0_modifyTimePresent());\n        assertTrue(xf.isBit1_accessTimePresent());\n        assertFalse(xf.isBit2_createTimePresent());\n        // Local length=5, Central length=1\n        assertEquals(5, xf.getLocalFileDataLength().getValue());\n        assertEquals(1, xf.getCentralDirectoryLength().getValue());\n\n        // get/set flags: 100\n        xf.setFlags((byte) 4);\n        assertEquals(4, xf.getFlags());\n        assertFalse(xf.isBit0_modifyTimePresent());\n        assertFalse(xf.isBit1_accessTimePresent());\n        assertTrue(xf.isBit2_createTimePresent());\n        // Local length=5, Central length=1\n        assertEquals(5, xf.getLocalFileDataLength().getValue());\n        assertEquals(1, xf.getCentralDirectoryLength().getValue());\n\n        // get/set flags: 111\n        xf.setFlags((byte) 7);\n        assertEquals(7, xf.getFlags());\n        assertTrue(xf.isBit0_modifyTimePresent());\n        assertTrue(xf.isBit1_accessTimePresent());\n        assertTrue(xf.isBit2_createTimePresent());\n        // Local length=13, Central length=5\n        assertEquals(13, xf.getLocalFileDataLength().getValue());\n        assertEquals(5, xf.getCentralDirectoryLength().getValue());\n\n        // get/set flags: 11111111\n        xf.setFlags((byte) -1);\n        assertEquals(-1, xf.getFlags());\n        assertTrue(xf.isBit0_modifyTimePresent());\n        assertTrue(xf.isBit1_accessTimePresent());\n        assertTrue(xf.isBit2_createTimePresent());\n        // Local length=13, Central length=5\n        assertEquals(13, xf.getLocalFileDataLength().getValue());\n        assertEquals(5, xf.getCentralDirectoryLength().getValue());\n    }",
    "Compress-5_testRead7ZipMultiVolumeArchiveForStream": "    public void testRead7ZipMultiVolumeArchiveForStream() throws IOException,\n\t    URISyntaxException {\n\t\n\tURL zip = getClass().getResource(\"/apache-maven-2.2.1.zip.001\");\n\tFileInputStream archive = new FileInputStream(\n\t\tnew File(new URI(zip.toString())));\n\tZipArchiveInputStream zi = null;\n\ttry {\n\t    zi = new ZipArchiveInputStream(archive,null,false);\n\t    \n\t    // these are the entries that are supposed to be processed\n\t    // correctly without any problems\n\t    for (int i = 0; i < ENTRIES.length; i++) {\n\t\tassertEquals(ENTRIES[i], zi.getNextEntry().getName());\n\t    }\n\t    \n\t    // this is the last entry that is truncated\n\t    ArchiveEntry lastEntry = zi.getNextEntry();\n\t    assertEquals(LAST_ENTRY_NAME, lastEntry.getName());\n\t    byte [] buffer = new byte [4096];\n\t    \n\t    // before the fix, we'd get 0 bytes on this read and all\n\t    // subsequent reads thus a client application might enter\n\t    // an infinite loop after the fix, we should get an\n\t    // exception\n\t    try {\n                int read = 0;\n\t\twhile ((read = zi.read(buffer)) > 0) { }\n\t\tfail(\"shouldn't be able to read from truncated entry\");\n\t    } catch (IOException e) {\n                assertEquals(\"Truncated ZIP file\", e.getMessage());\n\t    }\n\t    \n\t    // and now we get another entry, which should also yield\n\t    // an exception\n\t    try {\n\t\tzi.getNextEntry();\n\t\tfail(\"shouldn't be able to read another entry from truncated\"\n                     + \" file\");\n\t    } catch (IOException e) {\n\t\t// this is to be expected\n\t    }\n\t} finally {\n\t    if (zi != null) {\n\t\tzi.close();\n\t    }\n\t}\n    }",
    "Compress-7_testRoundTripNames": "    public void testRoundTripNames(){\n        checkName(\"\");\n        checkName(\"The quick brown fox\\n\");\n        checkName(\"\\177\");\n        // checkName(\"\\0\"); // does not work, because NUL is ignored\n        // COMPRESS-114\n        checkName(\"0302-0601-3F06W220ZBLALALACANDC04060302MOE.model\");\n    }",
    "Compress-8_testParseOctalInvalid": "    public void testParseOctalInvalid() throws Exception{\n        byte [] buffer;\n        buffer=new byte[0]; // empty byte array\n        try {\n            TarUtils.parseOctal(buffer,0, buffer.length);\n            fail(\"Expected IllegalArgumentException - should be at least 2 bytes long\");\n        } catch (IllegalArgumentException expected) {\n        }\n        buffer=new byte[]{0}; // 1-byte array\n        try {\n            TarUtils.parseOctal(buffer,0, buffer.length);\n            fail(\"Expected IllegalArgumentException - should be at least 2 bytes long\");\n        } catch (IllegalArgumentException expected) {\n        }\n        buffer=new byte[]{0,0,' '}; // not all NULs\n        try {\n            TarUtils.parseOctal(buffer,0, buffer.length);\n            fail(\"Expected IllegalArgumentException - not all NULs\");\n        } catch (IllegalArgumentException expected) {\n        }\n        buffer=new byte[]{' ',0,0,0}; // not all NULs\n        try {\n            TarUtils.parseOctal(buffer,0, buffer.length);\n            fail(\"Expected IllegalArgumentException - not all NULs\");\n        } catch (IllegalArgumentException expected) {\n        }\n        buffer = \"abcdef \".getBytes(\"UTF-8\"); // Invalid input\n        try {\n            TarUtils.parseOctal(buffer,0, buffer.length);\n            fail(\"Expected IllegalArgumentException\");\n        } catch (IllegalArgumentException expected) {\n        }\n        buffer = \"77777777777\".getBytes(\"UTF-8\"); // Invalid input - no trailer\n        try {\n            TarUtils.parseOctal(buffer,0, buffer.length);\n            fail(\"Expected IllegalArgumentException - no trailer\");\n        } catch (IllegalArgumentException expected) {\n        }\n        buffer = \" 0 07 \".getBytes(\"UTF-8\"); // Invalid - embedded space\n        try {\n            TarUtils.parseOctal(buffer,0, buffer.length);\n            fail(\"Expected IllegalArgumentException - embedded space\");\n        } catch (IllegalArgumentException expected) {\n        }\n        buffer = \" 0\\00007 \".getBytes(\"UTF-8\"); // Invalid - embedded NUL\n        try {\n            TarUtils.parseOctal(buffer,0, buffer.length);\n            fail(\"Expected IllegalArgumentException - embedded NUL\");\n        } catch (IllegalArgumentException expected) {\n        }\n    }",
    "Csv-10_testHeader": "    public void testHeader() throws IOException {\n        final StringWriter sw = new StringWriter();\n        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteChar(null)\n                .withHeader(\"C1\", \"C2\", \"C3\"));\n        printer.printRecord(\"a\", \"b\", \"c\");\n        printer.printRecord(\"x\", \"y\", \"z\");\n        assertEquals(\"C1,C2,C3\\r\\na,b,c\\r\\nx,y,z\\r\\n\", sw.toString());\n        printer.close();\n    }",
    "Csv-11_testHeaderMissingWithNull": "    public void testHeaderMissingWithNull() throws Exception {\n        final Reader in = new StringReader(\"a,,c,,d\\n1,2,3,4\\nx,y,z,zz\");\n        CSVFormat.DEFAULT.withHeader().withNullString(\"\").withIgnoreEmptyHeaders(true).parse(in).iterator();\n    }",
    "Csv-14_testEscapeBackslash1": "    public void testEscapeBackslash1() throws IOException {\n        StringWriter sw = new StringWriter();\n        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(QUOTE_CH))) {\n            printer.print(\"\\\\\");\n        }\n        assertEquals(\"\\\\\", sw.toString());\n    }",
    "Csv-14_testEscapeBackslash4": "    public void testEscapeBackslash4() throws IOException {\n        StringWriter sw = new StringWriter();\n        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(QUOTE_CH))) {\n            printer.print(\"\\\\\\\\\");\n        }\n        assertEquals(\"\\\\\\\\\", sw.toString());\n    }",
    "Csv-14_testEscapeBackslash5": "    public void testEscapeBackslash5() throws IOException {\n        StringWriter sw = new StringWriter();\n        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(QUOTE_CH))) {\n            printer.print(\"\\\\\\\\\");\n        }\n        assertEquals(\"\\\\\\\\\", sw.toString());\n    }",
    "Csv-14_testEscapeNull1": "    public void testEscapeNull1() throws IOException {\n        StringWriter sw = new StringWriter();\n        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\n            printer.print(\"\\\\\");\n        }\n        assertEquals(\"\\\\\", sw.toString());\n    }",
    "Csv-14_testEscapeNull4": "    public void testEscapeNull4() throws IOException {\n        StringWriter sw = new StringWriter();\n        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\n            printer.print(\"\\\\\\\\\");\n        }\n        assertEquals(\"\\\\\\\\\", sw.toString());\n    }",
    "Csv-14_testEscapeNull5": "    public void testEscapeNull5() throws IOException {\n        StringWriter sw = new StringWriter();\n        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\n            printer.print(\"\\\\\\\\\");\n        }\n        assertEquals(\"\\\\\\\\\", sw.toString());\n    }",
    "Csv-15_testDontQuoteEuroFirstChar": "    public void testDontQuoteEuroFirstChar() throws IOException {\n        final StringWriter sw = new StringWriter();\n        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.RFC4180)) {\n            printer.printRecord(EURO_CH, \"Deux\");\n            assertEquals(EURO_CH + \",Deux\" + recordSeparator, sw.toString());\n        }\n    }",
    "Csv-1_testGetLineNumberWithCR": "    public void testGetLineNumberWithCR() throws Exception {\n        CSVParser parser = new CSVParser(\"a\\rb\\rc\", CSVFormat.DEFAULT.withLineSeparator(\"\\r\"));\n        \n        assertEquals(0, parser.getLineNumber());\n        assertNotNull(parser.getRecord());\n        assertEquals(1, parser.getLineNumber());\n        assertNotNull(parser.getRecord());\n        assertEquals(2, parser.getLineNumber());\n        assertNotNull(parser.getRecord());\n        assertEquals(2, parser.getLineNumber());\n        assertNull(parser.getRecord());\n    }",
    "Csv-2_testGetStringInconsistentRecord": "    public void testGetStringInconsistentRecord() {\n        header.put(\"fourth\", Integer.valueOf(4));\n        recordWithHeader.get(\"fourth\");\n    }",
    "Csv-3_testBackslashEscaping": "    public void testBackslashEscaping() throws IOException {\n\n        // To avoid confusion over the need for escaping chars in java code,\n        // We will test with a forward slash as the escape char, and a single\n        // quote as the encapsulator.\n\n        final String code =\n                \"one,two,three\\n\" // 0\n                        + \"'',''\\n\"       // 1) empty encapsulators\n                        + \"/',/'\\n\"       // 2) single encapsulators\n                        + \"'/'','/''\\n\"   // 3) single encapsulators encapsulated via escape\n                        + \"'''',''''\\n\"   // 4) single encapsulators encapsulated via doubling\n                        + \"/,,/,\\n\"       // 5) separator escaped\n                        + \"//,//\\n\"       // 6) escape escaped\n                        + \"'//','//'\\n\"   // 7) escape escaped in encapsulation\n                        + \"   8   ,   \\\"quoted \\\"\\\" /\\\" // string\\\"   \\n\"     // don't eat spaces\n                        + \"9,   /\\n   \\n\"  // escaped newline\n                        + \"\";\n        final String[][] res = {\n                {\"one\", \"two\", \"three\"}, // 0\n                {\"\", \"\"},                // 1\n                {\"'\", \"'\"},              // 2\n                {\"'\", \"'\"},              // 3\n                {\"'\", \"'\"},              // 4\n                {\",\", \",\"},              // 5\n                {\"/\", \"/\"},              // 6\n                {\"/\", \"/\"},              // 7\n                {\"   8   \", \"   \\\"quoted \\\"\\\" /\\\" / string\\\"   \"},\n                {\"9\", \"   \\n   \"},\n        };\n\n\n        final CSVFormat format = CSVFormat.newBuilder(',').withQuoteChar('\\'').withEscape('/')\n                               .withIgnoreEmptyLines(true).withRecordSeparator(CRLF).build();\n\n        final CSVParser parser = new CSVParser(code, format);\n        final List<CSVRecord> records = parser.getRecords();\n        assertTrue(records.size() > 0);\n\n        Utils.compare(\"Records do not match expected result\", res, records);\n    }",
    "Csv-3_testEscapedCharacter": "    public void testEscapedCharacter() throws Exception {\n        final Lexer lexer = getLexer(\"character\\\\aEscaped\", formatWithEscaping);\n        assertThat(lexer.nextToken(new Token()), hasContent(\"character\\\\aEscaped\"));\n    }",
    "Csv-3_testEscapedMySqlNullValue": "    public void testEscapedMySqlNullValue() throws Exception {\n        // MySQL uses \\N to symbolize null values. We have to restore this\n        final Lexer lexer = getLexer(\"character\\\\NEscaped\", formatWithEscaping);\n        assertThat(lexer.nextToken(new Token()), hasContent(\"character\\\\NEscaped\"));\n    }",
    "Csv-4_testNoHeaderMap": "    public void testNoHeaderMap() throws Exception {\n        final CSVParser parser = CSVParser.parse(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT);\n        Assert.assertNull(parser.getHeaderMap());\n    }",
    "Csv-5_testNullRecordSeparatorCsv106": "    public void testNullRecordSeparatorCsv106() {\n        final CSVFormat format = CSVFormat.newFormat(';').withSkipHeaderRecord(true).withHeader(\"H1\", \"H2\");\n        final String formatStr = format.format(\"A\", \"B\");\n        assertNotNull(formatStr);\n        assertFalse(formatStr.endsWith(\"null\"));\n    }",
    "Csv-6_testToMapWithShortRecord": "    public void testToMapWithShortRecord() throws Exception {\n       final CSVParser parser =  CSVParser.parse(\"a,b\", CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\"));\n       final CSVRecord shortRec = parser.iterator().next();\n       shortRec.toMap();\n    }",
    "Csv-9_testToMapWithNoHeader": "    public void testToMapWithNoHeader() throws Exception {\n       final CSVParser parser =  CSVParser.parse(\"a,b\", CSVFormat.newFormat(','));\n       final CSVRecord shortRec = parser.iterator().next();\n       Map<String, String> map = shortRec.toMap();\n       assertNotNull(\"Map is not null.\", map);\n       assertTrue(\"Map is empty.\", map.isEmpty());\n    }",
    "Gson-11_testNumberAsStringDeserialization": "  public void testNumberAsStringDeserialization() {\n    Number value = gson.fromJson(\"\\\"18\\\"\", Number.class);\n    assertEquals(18, value.intValue());\n  }",
    "Gson-12_testSkipValue_emptyJsonObject": "  public void testSkipValue_emptyJsonObject() throws IOException {\n    JsonTreeReader in = new JsonTreeReader(new JsonObject());\n    in.skipValue();\n    assertEquals(JsonToken.END_DOCUMENT, in.peek());\n  }",
    "Gson-12_testSkipValue_filledJsonObject": "  public void testSkipValue_filledJsonObject() throws IOException {\n    JsonObject jsonObject = new JsonObject();\n    JsonArray jsonArray = new JsonArray();\n    jsonArray.add('c');\n    jsonArray.add(\"text\");\n    jsonObject.add(\"a\", jsonArray);\n    jsonObject.addProperty(\"b\", true);\n    jsonObject.addProperty(\"i\", 1);\n    jsonObject.add(\"n\", JsonNull.INSTANCE);\n    JsonObject jsonObject2 = new JsonObject();\n    jsonObject2.addProperty(\"n\", 2L);\n    jsonObject.add(\"o\", jsonObject2);\n    jsonObject.addProperty(\"s\", \"text\");\n    JsonTreeReader in = new JsonTreeReader(jsonObject);\n    in.skipValue();\n    assertEquals(JsonToken.END_DOCUMENT, in.peek());\n  }",
    "Gson-13_testNegativeZero": "  public void testNegativeZero() throws Exception {\n\t  \tJsonReader reader = new JsonReader(reader(\"[-0]\"));\n\t    reader.setLenient(false);\n\t    reader.beginArray();\n\t    assertEquals(NUMBER, reader.peek());\n\t    assertEquals(\"-0\", reader.nextString());\n  }",
    "Gson-15_testNonFiniteDoublesWhenLenient": "  public void testNonFiniteDoublesWhenLenient() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    jsonWriter.setLenient(true);\n    jsonWriter.beginArray();\n    jsonWriter.value(Double.NaN);\n    jsonWriter.value(Double.NEGATIVE_INFINITY);\n    jsonWriter.value(Double.POSITIVE_INFINITY);\n    jsonWriter.endArray();\n    assertEquals(\"[NaN,-Infinity,Infinity]\", stringWriter.toString());\n  }",
    "Gson-16_testRecursiveTypeVariablesResolve1": "  public void testRecursiveTypeVariablesResolve1() throws Exception {\n    TypeAdapter<TestType> adapter = new Gson().getAdapter(TestType.class);\n    assertNotNull(adapter);\n  }",
    "Gson-16_testRecursiveTypeVariablesResolve12": "  public void testRecursiveTypeVariablesResolve12() throws Exception {\n    TypeAdapter<TestType2> adapter = new Gson().getAdapter(TestType2.class);\n    assertNotNull(adapter);\n  }",
    "Gson-17_testNullValue": "  public void testNullValue() throws Exception {\n    DefaultDateTypeAdapter adapter = new DefaultDateTypeAdapter(Date.class);\n    assertNull(adapter.fromJson(\"null\"));\n    assertEquals(\"null\", adapter.toJson(null));\n  }",
    "Gson-17_testUnexpectedToken": "  public void testUnexpectedToken() throws Exception {\n    try {\n      DefaultDateTypeAdapter adapter = new DefaultDateTypeAdapter(Date.class);\n      adapter.fromJson(\"{}\");\n      fail(\"Unexpected token should fail.\");\n    } catch (IllegalStateException expected) { }\n  }",
    "Gson-18_testIssue1107": "  public void testIssue1107() {\n    String json = \"{\\n\" +\n            \"  \\\"inBig\\\": {\\n\" +\n            \"    \\\"key\\\": [\\n\" +\n            \"      { \\\"inSmall\\\": \\\"hello\\\" }\\n\" +\n            \"    ]\\n\" +\n            \"  }\\n\" +\n            \"}\";\n    BigClass bigClass = new Gson().fromJson(json, BigClass.class);\n    SmallClass small = bigClass.inBig.get(\"key\").get(0);\n    assertNotNull(small);\n    assertEquals(\"hello\", small.inSmall);\n  }",
    "Gson-5_testDateDeserializationISO8601": "  public void testDateDeserializationISO8601() throws Exception {\n  \tDefaultDateTypeAdapter adapter = new DefaultDateTypeAdapter();\n    assertParsed(\"1970-01-01T00:00:00.000Z\", adapter);\n    assertParsed(\"1970-01-01T00:00Z\", adapter);\n    assertParsed(\"1970-01-01T00:00:00+00:00\", adapter);\n    assertParsed(\"1970-01-01T01:00:00+01:00\", adapter);\n    assertParsed(\"1970-01-01T01:00:00+01\", adapter);\n  }",
    "Gson-6_testNullSafeBugDeserialize": "  public void testNullSafeBugDeserialize() throws Exception {\n    Device device = gson.fromJson(\"{'id':'ec57803e2'}\", Device.class);\n    assertEquals(\"ec57803e2\", device.id);\n  }",
    "Gson-6_testNullSafeBugSerialize": "  public void testNullSafeBugSerialize() throws Exception {\n    Device device = new Device(\"ec57803e\");\n    gson.toJson(device);\n  }",
    "JacksonCore-11_testSymbolTableExpansionBytes": "    public void testSymbolTableExpansionBytes() throws Exception {\n        _testSymbolTableExpansion(true);\n    }",
    "JacksonCore-15_testNotAllowMultipleMatches": "    public void testNotAllowMultipleMatches() throws Exception\n    {\n    \tString jsonString = aposToQuotes(\"{'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'value':4,'b':true}\");\n        JsonParser p0 = JSON_F.createParser(jsonString);\n        JsonParser p = new FilteringParserDelegate(p0,\n               new NameMatchFilter(\"value\"),\n                   false, // includePath\n                   false // multipleMatches -false\n                );\n        String result = readAndWrite(JSON_F, p);\n        assertEquals(aposToQuotes(\"3\"), result);\n    }",
    "JacksonCore-20_testAsEmbedded": "    public void testAsEmbedded() throws Exception\n    {\n        JsonGenerator g;\n\n        StringWriter sw = new StringWriter();\n        g = JSON_F.createGenerator(sw);\n        g.writeEmbeddedObject(null);\n        g.close();\n        assertEquals(\"null\", sw.toString());\n\n        ByteArrayOutputStream bytes =  new ByteArrayOutputStream(100);\n        g = JSON_F.createGenerator(bytes);\n        g.writeEmbeddedObject(null);\n        g.close();\n        assertEquals(\"null\", bytes.toString(\"UTF-8\"));\n\n        // also, for fun, try illegal unknown thingy\n\n        try {\n            g = JSON_F.createGenerator(bytes);\n            // try writing a Class object\n            g.writeEmbeddedObject(getClass());\n            fail(\"Expected an exception\");\n            g.close(); // never gets here\n        } catch (JsonGenerationException e) {\n            verifyException(e, \"No native support for\");\n        }\n    }",
    "JacksonCore-20_testBinaryAsEmbeddedObject": "    public void testBinaryAsEmbeddedObject() throws Exception\n    {\n        JsonGenerator g;\n\n        StringWriter sw = new StringWriter();\n        g = JSON_F.createGenerator(sw);\n        g.writeEmbeddedObject(WIKIPEDIA_BASE64_AS_BYTES);\n        g.close();\n        assertEquals(quote(WIKIPEDIA_BASE64_ENCODED), sw.toString());\n\n        ByteArrayOutputStream bytes =  new ByteArrayOutputStream(100);\n        g = JSON_F.createGenerator(bytes);\n        g.writeEmbeddedObject(WIKIPEDIA_BASE64_AS_BYTES);\n        g.close();\n        assertEquals(quote(WIKIPEDIA_BASE64_ENCODED), bytes.toString(\"UTF-8\"));\n    }",
    "JacksonCore-21_testBasicSingleMatchFilteringWithPath": "    public void testBasicSingleMatchFilteringWithPath() throws Exception\n    {\n        JsonParser p0 = JSON_F.createParser(SIMPLE);\n        JsonParser p = new FilteringParserDelegate(p0,\n               new NameMatchFilter(\"value\"),\n                   true, // includePath\n                   false // multipleMatches\n                );\n\n// {'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}\n        String result = readAndWrite(JSON_F, p);\n        assertEquals(aposToQuotes(\"{'ob':{'value':3}}\"), result);\n    }",
    "JacksonCore-21_testSkippingForSingleWithPath": "    public void testSkippingForSingleWithPath() throws Exception\n    {\n        JsonParser p0 = JSON_F.createParser(SIMPLE);\n        JsonParser p = new FilteringParserDelegate(p0,\n               new NameMatchFilter(\"value\"),\n                   true, // includePath\n                   false // multipleMatches\n                );\n\n//        assertEquals(aposToQuotes(\"{'ob':{'value':3}}\"), result);\n\n        assertToken(JsonToken.START_OBJECT, p.nextToken());\n        p.skipChildren();\n        assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());\n        assertNull(p.nextToken());\n    }",
    "JacksonCore-21_testTokensSingleMatchWithPath": "    public void testTokensSingleMatchWithPath() throws Exception\n    {\n        JsonParser p0 = JSON_F.createParser(SIMPLE);\n        JsonParser p = new FilteringParserDelegate(p0,\n               new NameMatchFilter(\"value\"),\n                   true, // includePath\n                   false // multipleMatches\n                );\n\n        assertFalse(p.hasCurrentToken());\n        assertNull(p.getCurrentToken());\n        assertEquals(JsonTokenId.ID_NO_TOKEN, p.getCurrentTokenId());\n        assertFalse(p.isExpectedStartObjectToken());\n        assertFalse(p.isExpectedStartArrayToken());\n        \n// {'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}\n//      String result = readAndWrite(JSON_F, p);\n//      assertEquals(aposToQuotes(\"{'ob':{'value':3}}\"), result);\n\n        assertToken(JsonToken.START_OBJECT, p.nextToken());\n        assertEquals(JsonToken.START_OBJECT, p.getCurrentToken());\n        assertTrue(p.isExpectedStartObjectToken());\n        assertFalse(p.isExpectedStartArrayToken());\n\n        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n        assertEquals(JsonToken.FIELD_NAME, p.getCurrentToken());\n        assertEquals(\"ob\", p.getCurrentName());\n//        assertEquals(\"ob\", p.getText());\n\n        assertToken(JsonToken.START_OBJECT, p.nextToken());\n        assertEquals(\"ob\", p.getCurrentName());\n\n        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n        assertEquals(\"value\", p.getCurrentName());\n        assertEquals(\"value\", p.getText());\n\n        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n        assertEquals(JsonToken.VALUE_NUMBER_INT, p.getCurrentToken());\n        assertEquals(NumberType.INT, p.getNumberType());\n        assertEquals(3, p.getIntValue());\n        assertEquals(\"value\", p.getCurrentName());\n\n        assertToken(JsonToken.END_OBJECT, p.nextToken());\n        assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());\n\n        assertToken(JsonToken.END_OBJECT, p.nextToken());\n        assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());\n\n        p.clearCurrentToken();\n        assertNull(p.getCurrentToken());\n        \n        p.close();\n    }",
    "JacksonCore-23_testInvalidSubClass": "    public void testInvalidSubClass() throws Exception\n    {\n        DefaultPrettyPrinter pp = new MyPrettyPrinter();\n        try {\n            pp.createInstance();\n            fail(\"Should not pass\");\n        } catch (IllegalStateException e) {\n            verifyException(e, \"does not override\");\n        }\n    }",
    "JacksonCore-25_testUnquotedIssue510": "    public void testUnquotedIssue510() throws Exception\n    {\n        // NOTE! Requires longer input buffer to trigger longer codepath\n        char[] fullChars = new char[4001];\n        for (int i = 0; i < 3998; i++) {\n             fullChars[i] = ' ';\n        }\n        fullChars[3998] = '{';\n        fullChars[3999] = 'a';\n        fullChars[4000] = 256;\n\n        JsonParser p = UNQUOTED_FIELDS_F.createParser(new java.io.StringReader(new String(fullChars)));\n        assertToken(JsonToken.START_OBJECT, p.nextToken());\n        try {\n            p.nextToken();\n            fail(\"Should not pass\");\n        } catch (JsonParseException e) {\n            ; // should fail here\n        }\n        p.close();\n    }\n\n    /*\n    /****************************************************************\n    /* Secondary test methods\n    /****************************************************************\n     */\n    \n    private void _testLargeUnquoted(int mode) throws Exception\n    {\n        StringBuilder sb = new StringBuilder(5000);\n        sb.append(\"[\\n\");\n        //final int REPS = 2000;\n        final int REPS = 1050;\n        for (int i = 0; i < REPS; ++i) {\n            if (i > 0) {\n                sb.append(',');\n                if ((i & 7) == 0) {\n                    sb.append('\\n');\n                }\n            }\n            sb.append(\"{\");\n            sb.append(\"abc\").append(i&127).append(':');\n            sb.append((i & 1) != 0);\n            sb.append(\"}\\n\");\n        }\n        sb.append(\"]\");\n        String JSON = sb.toString();\n        JsonParser p = createParser(UNQUOTED_FIELDS_F, mode, JSON);\n        assertToken(JsonToken.START_ARRAY, p.nextToken());\n        for (int i = 0; i < REPS; ++i) {\n            assertToken(JsonToken.START_OBJECT, p.nextToken());\n            assertToken(JsonToken.FIELD_NAME, p.nextToken());\n            assertEquals(\"abc\"+(i&127), p.getCurrentName());\n            assertToken(((i&1) != 0) ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE, p.nextToken());\n            assertToken(JsonToken.END_OBJECT, p.nextToken());\n        }\n        assertToken(JsonToken.END_ARRAY, p.nextToken());\n        p.close();\n    }\n\n    private void _testSimpleUnquoted(int mode) throws Exception\n    {\n        String JSON = \"{ a : 1, _foo:true, $:\\\"money!\\\", \\\" \\\":null }\";\n        JsonParser p = createParser(UNQUOTED_FIELDS_F, mode, JSON);\n\n        assertToken(JsonToken.START_OBJECT, p.nextToken());\n        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n        assertEquals(\"a\", p.getCurrentName());\n        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n        assertEquals(\"_foo\", p.getCurrentName());\n        assertToken(JsonToken.VALUE_TRUE, p.nextToken());\n        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n        assertEquals(\"$\", p.getCurrentName());\n        assertToken(JsonToken.VALUE_STRING, p.nextToken());\n        assertEquals(\"money!\", p.getText());\n\n        // and then regular quoted one should still work too:\n        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n        assertEquals(\" \", p.getCurrentName());\n\n        assertToken(JsonToken.VALUE_NULL, p.nextToken());\n\n        assertToken(JsonToken.END_OBJECT, p.nextToken());\n        p.close();\n\n        // Another thing, as per [Issue#102]: numbers\n\n        JSON = \"{ 123:true,4:false }\";\n        p = createParser(UNQUOTED_FIELDS_F, mode, JSON);\n\n        assertToken(JsonToken.START_OBJECT, p.nextToken());\n        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n        assertEquals(\"123\", p.getCurrentName());\n        assertToken(JsonToken.VALUE_TRUE, p.nextToken());\n\n        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n        assertEquals(\"4\", p.getCurrentName());\n        assertToken(JsonToken.VALUE_FALSE, p.nextToken());\n\n        assertToken(JsonToken.END_OBJECT, p.nextToken());\n        p.close();\n    }\n}",
    "JacksonCore-26_testLocationOffsets": "    public void testLocationOffsets() throws Exception\n    {\n        JsonParser parser = DEFAULT_F.createNonBlockingByteArrayParser();\n        ByteArrayFeeder feeder = (ByteArrayFeeder) parser.getNonBlockingInputFeeder();\n\n        byte[] input = utf8Bytes(\"[[[\");\n\n        feeder.feedInput(input, 2, 3);\n        assertEquals(JsonToken.START_ARRAY, parser.nextToken());\n        assertEquals(1, parser.getCurrentLocation().getByteOffset());\n        assertEquals(1, parser.getTokenLocation().getByteOffset());\n        assertEquals(1, parser.getCurrentLocation().getLineNr());\n        assertEquals(1, parser.getTokenLocation().getLineNr());\n        assertEquals(2, parser.getCurrentLocation().getColumnNr());\n        assertEquals(1, parser.getTokenLocation().getColumnNr());\n\n        feeder.feedInput(input, 0, 1);\n        assertEquals(JsonToken.START_ARRAY, parser.nextToken());\n        assertEquals(2, parser.getCurrentLocation().getByteOffset());\n        assertEquals(2, parser.getTokenLocation().getByteOffset());\n        assertEquals(1, parser.getCurrentLocation().getLineNr());\n        assertEquals(1, parser.getTokenLocation().getLineNr());\n        assertEquals(3, parser.getCurrentLocation().getColumnNr());\n        assertEquals(2, parser.getTokenLocation().getColumnNr());\n        parser.close();\n    }",
    "JacksonCore-3_testOffsetWithInputOffset": "    public void testOffsetWithInputOffset() throws Exception\n    {\n        final JsonFactory f = new JsonFactory();\n        JsonLocation loc;\n        JsonParser p;\n        // 3 spaces before, 2 after, just for padding\n        byte[] b = \"   { }  \".getBytes(\"UTF-8\");\n\n        // and then peel them off\n        p = f.createParser(b, 3, b.length-5);\n        assertToken(JsonToken.START_OBJECT, p.nextToken());\n\n        loc = p.getTokenLocation();\n        assertEquals(0L, loc.getByteOffset());\n        assertEquals(-1L, loc.getCharOffset());\n        assertEquals(1, loc.getLineNr());\n        assertEquals(1, loc.getColumnNr());\n        \n        loc = p.getCurrentLocation();\n        assertEquals(1L, loc.getByteOffset());\n        assertEquals(-1L, loc.getCharOffset());\n        assertEquals(1, loc.getLineNr());\n        assertEquals(2, loc.getColumnNr());\n\n        p.close();\n    }",
    "JacksonCore-4_testExpand": "      public void testExpand()\n      {\n          TextBuffer tb = new TextBuffer(new BufferRecycler());\n          char[] buf = tb.getCurrentSegment();\n\n          while (buf.length < 500 * 1000) {\n              char[] old = buf;\n              buf = tb.expandCurrentSegment();\n              if (old.length >= buf.length) {\n                  fail(\"Expected buffer of \"+old.length+\" to expand, did not, length now \"+buf.length);\n              }\n          }\n      }",
    "JacksonCore-5_testWonkyNumber173": "    public void testWonkyNumber173() throws Exception\n    {\n        JsonPointer ptr = JsonPointer.compile(\"/1e0\");\n        assertFalse(ptr.matches());\n    }",
    "JacksonCore-6_testIZeroIndex": "    public void testIZeroIndex() throws Exception\n    {\n        JsonPointer ptr = JsonPointer.compile(\"/0\");\n        assertEquals(0, ptr.getMatchingIndex());\n        ptr = JsonPointer.compile(\"/00\");\n        assertEquals(-1, ptr.getMatchingIndex());\n    }",
    "JacksonCore-7_testFailOnWritingStringNotFieldNameBytes": "    public void testFailOnWritingStringNotFieldNameBytes() throws Exception {\n        _testFailOnWritingStringNotFieldName(F, false);\n    }",
    "JacksonCore-7_testFailOnWritingStringNotFieldNameChars": "    public void testFailOnWritingStringNotFieldNameChars() throws Exception {\n        _testFailOnWritingStringNotFieldName(F, true);        \n    }",
    "JacksonCore-8_testEmpty": "    public void testEmpty() {\n        TextBuffer tb = new TextBuffer(new BufferRecycler());\n        tb.resetWithEmpty();\n\n        assertTrue(tb.getTextBuffer().length == 0);\n        tb.contentsAsString();\n        assertTrue(tb.getTextBuffer().length == 0);\n    }",
    "JacksonDatabind-100_testBase64Text": "    public void testBase64Text() throws Exception\n    {\n        // let's actually iterate over sets of encoding modes, lengths\n        \n        final int[] LENS = { 1, 2, 3, 4, 7, 9, 32, 33, 34, 35 };\n        final Base64Variant[] VARIANTS = {\n                Base64Variants.MIME,\n                Base64Variants.MIME_NO_LINEFEEDS,\n                Base64Variants.MODIFIED_FOR_URL,\n                Base64Variants.PEM\n        };\n\n        for (int len : LENS) {\n            byte[] input = new byte[len];\n            for (int i = 0; i < input.length; ++i) {\n                input[i] = (byte) i;\n            }\n            for (Base64Variant variant : VARIANTS) {\n                TextNode n = new TextNode(variant.encode(input));\n                byte[] data = null;\n                try {\n                    data = n.getBinaryValue(variant);\n                } catch (Exception e) {\n                    fail(\"Failed (variant \"+variant+\", data length \"+len+\"): \"+e.getMessage());\n                }\n                assertNotNull(data);\n                assertArrayEquals(data, input);\n\n                // 15-Aug-2018, tatu: [databind#2096] requires another test\n                JsonParser p = new TreeTraversingParser(n);\n                assertEquals(JsonToken.VALUE_STRING, p.nextToken());\n                try {\n                    data = p.getBinaryValue(variant);\n                } catch (Exception e) {\n                    fail(\"Failed (variant \"+variant+\", data length \"+len+\"): \"+e.getMessage());\n                }\n                assertNotNull(data);\n                assertArrayEquals(data, input);\n                p.close();\n            }\n        }\n    }",
    "JacksonDatabind-101_testIssue2088UnwrappedFieldsAfterLastCreatorProp": "    public void testIssue2088UnwrappedFieldsAfterLastCreatorProp() throws Exception\n    {\n        Issue2088Bean bean = MAPPER.readValue(\"{\\\"x\\\":1,\\\"a\\\":2,\\\"y\\\":3,\\\"b\\\":4}\", Issue2088Bean.class);\n        assertEquals(1, bean.x);\n        assertEquals(2, bean.w.a);\n        assertEquals(3, bean.y);\n        assertEquals(4, bean.w.b);\n    }",
    "JacksonDatabind-102_testSqlDateConfigOverride": "    public void testSqlDateConfigOverride() throws Exception\n    {\n        ObjectMapper mapper = newObjectMapper();\n        mapper.configOverride(java.sql.Date.class)\n            .setFormat(JsonFormat.Value.forPattern(\"yyyy+MM+dd\"));        \n        assertEquals(\"\\\"1980+04+14\\\"\",\n            mapper.writeValueAsString(java.sql.Date.valueOf(\"1980-04-14\")));\n    }",
    "JacksonDatabind-107_testWithDeserializationProblemHandler": "    public void testWithDeserializationProblemHandler() throws Exception {\n        final ObjectMapper mapper = new ObjectMapper()\n                .enableDefaultTyping();\n        mapper.addHandler(new DeserializationProblemHandler() {\n            @Override\n            public JavaType handleUnknownTypeId(DeserializationContext ctxt, JavaType baseType, String subTypeId, TypeIdResolver idResolver, String failureMsg) throws IOException {\n//                System.out.println(\"Print out a warning here\");\n                return ctxt.constructType(Void.class);\n            }\n        });\n        GenericContent processableContent = mapper.readValue(JSON, GenericContent.class);\n        assertNotNull(processableContent.getInnerObjects());\n        assertEquals(2, processableContent.getInnerObjects().size());\n    }",
    "JacksonDatabind-112_testDeserializeBagOfStrings": "    public void testDeserializeBagOfStrings() throws Exception {\n        WithBagOfStrings result = MAPPER.readerFor(WithBagOfStrings.class)\n                .readValue(\"{\\\"strings\\\": [ \\\"a\\\", \\\"b\\\", \\\"c\\\"]}\");\n        assertEquals(3, result.getStrings().size());\n    }",
    "JacksonDatabind-11_testLocalPartialType609": "    public void testLocalPartialType609() throws Exception {\n        ObjectMapper mapper = new ObjectMapper();\n        \n        EntityContainer input = new EntityContainer(); \n        input.entity = new RuleForm(12);\n        String json = mapper.writeValueAsString(input);\n        \n        EntityContainer output = mapper.readValue(json, EntityContainer.class);\n        assertEquals(12, output.getEntity().value);\n    }",
    "JacksonDatabind-11_testLocalType728": "    public void testLocalType728() throws Exception\n    {\n        TypeFactory tf = TypeFactory.defaultInstance();\n        Method m = Issue728.class.getMethod(\"method\", CharSequence.class);\n        assertNotNull(m);\n\n        // Start with return type\n        // first type-erased\n        JavaType t = tf.constructType(m.getReturnType());\n        assertEquals(CharSequence.class, t.getRawClass());\n        // then generic\n        t = tf.constructType(m.getGenericReturnType());\n        assertEquals(CharSequence.class, t.getRawClass());\n\n        // then parameter type\n        t = tf.constructType(m.getParameterTypes()[0]);\n        assertEquals(CharSequence.class, t.getRawClass());\n        t = tf.constructType(m.getGenericParameterTypes()[0]);\n        assertEquals(CharSequence.class, t.getRawClass());\n    }",
    "JacksonDatabind-12_testCustomMapValueDeser735": "    public void testCustomMapValueDeser735() throws Exception {\n        String json = \"{\\\"map1\\\":{\\\"a\\\":1},\\\"map2\\\":{\\\"a\\\":1}}\";\n        TestMapBean735 bean = MAPPER.readValue(json, TestMapBean735.class);\n\n        assertEquals(100, bean.map1.get(\"a\").intValue());\n        assertEquals(1, bean.map2.get(\"a\").intValue());\n    }",
    "JacksonDatabind-16_testMixinWithBundles": "    public void testMixinWithBundles() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper().addMixIn(Foo.class, FooMixin.class);\n        String result = mapper.writeValueAsString(new Foo(\"result\"));\n        assertEquals(\"{\\\"bar\\\":\\\"result\\\"}\", result);\n    }",
    "JacksonDatabind-17_testArrayWithDefaultTyping": "    public void testArrayWithDefaultTyping() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper()\n            .enableDefaultTyping();\n\n        JsonNode array = mapper.readTree(\"[ 1, 2 ]\");\n        assertTrue(array.isArray());\n        assertEquals(2, array.size());\n\n        JsonNode obj = mapper.readTree(\"{ \\\"a\\\" : 2 }\");\n        assertTrue(obj.isObject());\n        assertEquals(1, obj.size());\n        assertEquals(2, obj.path(\"a\").asInt());\n    }",
    "JacksonDatabind-19_testMapToProperties": "    public void testMapToProperties() throws Exception\n    {\n        Bean bean = new Bean();\n        bean.A = 129;\n        bean.B = \"13\";\n        Properties props = MAPPER.convertValue(bean, Properties.class);\n\n        assertEquals(2, props.size());\n\n        assertEquals(\"13\", props.getProperty(\"B\"));\n        // should coercce non-Strings to Strings\n        assertEquals(\"129\", props.getProperty(\"A\"));\n    }",
    "JacksonDatabind-19_testProperties": "    public void testProperties()\n    {\n        TypeFactory tf = TypeFactory.defaultInstance();\n        JavaType t = tf.constructType(Properties.class);\n        assertEquals(MapType.class, t.getClass());\n        assertSame(Properties.class, t.getRawClass());\n\n        // so far so good. But how about parameterization?\n        assertSame(String.class, ((MapType) t).getKeyType().getRawClass());\n        assertSame(String.class, ((MapType) t).getContentType().getRawClass());\n    }",
    "JacksonDatabind-19_testReadProperties": "    public void testReadProperties() throws Exception\n    {\n        Properties props = MAPPER.readValue(aposToQuotes(\"{'a':'foo', 'b':123, 'c':true}\"),\n                Properties.class);\n        assertEquals(3, props.size());\n        assertEquals(\"foo\", props.getProperty(\"a\"));\n        assertEquals(\"123\", props.getProperty(\"b\"));\n        assertEquals(\"true\", props.getProperty(\"c\"));\n    }",
    "JacksonDatabind-1_testNullColumn": "    public void testNullColumn() throws Exception\n    {\n        assertEquals(\"[null,\\\"bar\\\"]\", MAPPER.writeValueAsString(new TwoStringsBean()));\n    }",
    "JacksonDatabind-24_testDateFormatConfig": "    public void testDateFormatConfig() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        TimeZone tz1 = TimeZone.getTimeZone(\"America/Los_Angeles\");\n        TimeZone tz2 = TimeZone.getTimeZone(\"Central Standard Time\");\n\n        // sanity checks\n        assertEquals(tz1, tz1);\n        assertEquals(tz2, tz2);\n        if (tz1.equals(tz2)) {\n            fail();\n        }\n\n        mapper.setTimeZone(tz1);\n        assertEquals(tz1, mapper.getSerializationConfig().getTimeZone());\n        assertEquals(tz1, mapper.getDeserializationConfig().getTimeZone());\n\n        // also better stick via reader/writer as well\n        assertEquals(tz1, mapper.writer().getConfig().getTimeZone());\n        assertEquals(tz1, mapper.reader().getConfig().getTimeZone());\n        \n        SimpleDateFormat f = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        f.setTimeZone(tz2);\n        mapper.setDateFormat(f);\n\n        // should not change the timezone tho\n        assertEquals(tz1, mapper.getSerializationConfig().getTimeZone());\n        assertEquals(tz1, mapper.getDeserializationConfig().getTimeZone());\n        assertEquals(tz1, mapper.writer().getConfig().getTimeZone());\n        assertEquals(tz1, mapper.reader().getConfig().getTimeZone());\n    }",
    "JacksonDatabind-27_testInverseExternalId928": "    public void testInverseExternalId928() throws Exception\n    {\n        final String CLASS = Payload928.class.getName();\n\n        ObjectMapper mapper = new ObjectMapper();\n\n        final String successCase = \"{\\\"payload\\\":{\\\"something\\\":\\\"test\\\"},\\\"class\\\":\\\"\"+CLASS+\"\\\"}\";\n        Envelope928 envelope1 = mapper.readValue(successCase, Envelope928.class);\n        assertNotNull(envelope1);\n        assertEquals(Payload928.class, envelope1._payload.getClass());\n\n        // and then re-ordered case that was problematic\n        final String failCase = \"{\\\"class\\\":\\\"\"+CLASS+\"\\\",\\\"payload\\\":{\\\"something\\\":\\\"test\\\"}}\";\n        Envelope928 envelope2 = mapper.readValue(failCase, Envelope928.class);\n        assertNotNull(envelope2);\n        assertEquals(Payload928.class, envelope2._payload.getClass());\n    }",
    "JacksonDatabind-28_testIssue941": "    public void testIssue941() throws Exception\n    {\n        ObjectNode object = MAPPER.createObjectNode();\n\n        String json = MAPPER.writeValueAsString(object);\n        System.out.println(\"json: \"+json);\n\n        ObjectNode de1 = MAPPER.readValue(json, ObjectNode.class);  // this works\n        System.out.println(\"Deserialized to ObjectNode: \"+de1);\n\n        MyValue de2 = MAPPER.readValue(json, MyValue.class);  // but this throws exception\n        System.out.println(\"Deserialized to MyValue: \"+de2);\n    }",
    "JacksonDatabind-33_testUnwrappedAsPropertyIndicator": "    public void testUnwrappedAsPropertyIndicator() throws Exception\n    {\n        Inner inner = new Inner();\n        inner.animal = \"Zebra\";\n\n        Outer outer = new Outer();\n        outer.inner = inner;\n\n        String actual = MAPPER.writeValueAsString(outer);\n\n        assertTrue(actual.contains(\"animal\"));\n        assertTrue(actual.contains(\"Zebra\"));\n        assertFalse(actual.contains(\"inner\"));\n    }",
    "JacksonDatabind-34_testSimpleNumbers": "    public void testSimpleNumbers() throws Exception\n    {\n        final StringBuilder sb = new StringBuilder();\n        \n        MAPPER.acceptJsonFormatVisitor(Numbers.class,\n                new JsonFormatVisitorWrapper.Base() {\n            @Override\n            public JsonObjectFormatVisitor expectObjectFormat(final JavaType type) {\n                return new JsonObjectFormatVisitor.Base(getProvider()) {\n                    @Override\n                    public void optionalProperty(BeanProperty prop) throws JsonMappingException {\n                        sb.append(\"[optProp \").append(prop.getName()).append(\"(\");\n                        JsonSerializer<Object> ser = null;\n                        if (prop instanceof BeanPropertyWriter) {\n                            BeanPropertyWriter bpw = (BeanPropertyWriter) prop;\n                            ser = bpw.getSerializer();\n                        }\n                        final SerializerProvider prov = getProvider();\n                        if (ser == null) {\n                            ser = prov.findValueSerializer(prop.getType(), prop);\n                        }\n                        ser.acceptJsonFormatVisitor(new JsonFormatVisitorWrapper.Base() {\n                            @Override\n                            public JsonNumberFormatVisitor expectNumberFormat(\n                                    JavaType type) throws JsonMappingException {\n                                return new JsonNumberFormatVisitor() {\n                                    @Override\n                                    public void format(JsonValueFormat format) {\n                                        sb.append(\"[numberFormat=\").append(format).append(\"]\");\n                                    }\n\n                                    @Override\n                                    public void enumTypes(Set<String> enums) { }\n\n                                    @Override\n                                    public void numberType(NumberType numberType) {\n                                        sb.append(\"[numberType=\").append(numberType).append(\"]\");\n                                    }\n                                };\n                            }\n\n                            @Override\n                            public JsonIntegerFormatVisitor expectIntegerFormat(JavaType type) throws JsonMappingException {\n                                return new JsonIntegerFormatVisitor() {\n                                    @Override\n                                    public void format(JsonValueFormat format) {\n                                        sb.append(\"[integerFormat=\").append(format).append(\"]\");\n                                    }\n\n                                    @Override\n                                    public void enumTypes(Set<String> enums) { }\n\n                                    @Override\n                                    public void numberType(NumberType numberType) {\n                                        sb.append(\"[numberType=\").append(numberType).append(\"]\");\n                                    }\n                                };\n                            }\n                        }, prop.getType());\n\n                        sb.append(\")]\");\n                    }\n                };\n            }\n        });\n        assertEquals(\"[optProp dec([numberType=BIG_DECIMAL])][optProp bigInt([numberType=BIG_INTEGER])]\",\n                sb.toString());\n    }",
    "JacksonDatabind-35_testSimple": "    public void testSimple() throws Exception\n    {\n        Company comp = new Company();\n        comp.addComputer(new DesktopComputer(\"computer-1\", \"Bangkok\"));\n        comp.addComputer(new DesktopComputer(\"computer-2\", \"Pattaya\"));\n        comp.addComputer(new LaptopComputer(\"computer-3\", \"Apple\"));\n\n        final ObjectMapper mapper = new ObjectMapper();\n\n        String json = mapper.writerWithDefaultPrettyPrinter()\n                .writeValueAsString(comp);\n\n        System.out.println(\"JSON: \"+json);\n\n        Company result = mapper.readValue(json, Company.class);\n        assertNotNull(result);\n        assertNotNull(result.computers);\n        assertEquals(3, result.computers.size());\n    }",
    "JacksonDatabind-37_testSimple": "      public void testSimple() throws Exception {\n          final ObjectMapper mapper = new ObjectMapper();\n          final String json = aposToQuotes(\"{'schemas': [{\\n\"\n              + \"  'name': 'FoodMart'\\n\"\n              + \"}]}\\n\");\n          mapper.readValue(json, JsonRoot.class);\n      }",
    "JacksonDatabind-39_testUnknownTypeIDRecovery": "    public void testUnknownTypeIDRecovery() throws Exception\n    {\n        ObjectReader reader = MAPPER.readerFor(CallRecord.class).without(\n                DeserializationFeature.FAIL_ON_INVALID_SUBTYPE);\n        String json = aposToQuotes(\"{'version':0.0,'application':'123',\"\n                +\"'item':{'type':'xevent','location':'location1'},\"\n                +\"'item2':{'type':'event','location':'location1'}}\");\n        // can't read item2 - which is valid\n        CallRecord r = reader.readValue(json);\n        assertNull(r.item);\n        assertNotNull(r.item2);\n\n        json = aposToQuotes(\"{'item':{'type':'xevent','location':'location1'}, 'version':0.0,'application':'123'}\");\n        CallRecord r3 = reader.readValue(json);\n        assertNull(r3.item);\n        assertEquals(\"123\", r3.application);\n    }",
    "JacksonDatabind-42_testLocale": "    public void testLocale() throws IOException\n    {\n        assertEquals(new Locale(\"en\"), MAPPER.readValue(quote(\"en\"), Locale.class));\n        assertEquals(new Locale(\"es\", \"ES\"), MAPPER.readValue(quote(\"es_ES\"), Locale.class));\n        assertEquals(new Locale(\"FI\", \"fi\", \"savo\"),\n                MAPPER.readValue(quote(\"fi_FI_savo\"), Locale.class));\n        // [databind#1123]\n        Locale loc = MAPPER.readValue(quote(\"\"), Locale.class);\n        assertSame(Locale.ROOT, loc);\n    }",
    "JacksonDatabind-44_testIssue1125WithDefault": "    public void testIssue1125WithDefault() throws Exception\n    {\n        Issue1125Wrapper result = MAPPER.readValue(aposToQuotes(\"{'value':{'a':3,'def':9,'b':5}}\"),\n        \t\tIssue1125Wrapper.class);\n        assertNotNull(result.value);\n        assertEquals(Default1125.class, result.value.getClass());\n        Default1125 impl = (Default1125) result.value;\n        assertEquals(3, impl.a);\n        assertEquals(5, impl.b);\n        assertEquals(9, impl.def);\n    }",
    "JacksonDatabind-45_testDateDefaultShape": "    public void testDateDefaultShape() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        // No @JsonFormat => default to user config\n        mapper.enable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n        String json = mapper.writeValueAsString(new DateAsDefaultBean(0L));\n        assertEquals(aposToQuotes(\"{'date':0}\"), json);\n        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n        json = mapper.writeValueAsString(new DateAsDefaultBean(0L));\n        assertEquals(aposToQuotes(\"{'date':'1970-01-01T00:00:00.000+0000'}\"), json);\n\n        // Empty @JsonFormat => default to user config\n        mapper.enable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n        json = mapper.writeValueAsString(new DateAsDefaultBeanWithEmptyJsonFormat(0L));\n        assertEquals(aposToQuotes(\"{'date':0}\"), json);\n        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n        json = mapper.writeValueAsString(new DateAsDefaultBeanWithEmptyJsonFormat(0L));\n        assertEquals(aposToQuotes(\"{'date':'1970-01-01T00:00:00.000+0000'}\"), json);\n\n        // @JsonFormat with Shape.ANY and pattern => STRING shape, regardless of user config\n        mapper.enable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n        json = mapper.writeValueAsString(new DateAsDefaultBeanWithPattern(0L));\n        assertEquals(aposToQuotes(\"{'date':'1970-01-01'}\"), json);\n        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n        json = mapper.writeValueAsString(new DateAsDefaultBeanWithPattern(0L));\n        assertEquals(aposToQuotes(\"{'date':'1970-01-01'}\"), json);\n\n        // @JsonFormat with Shape.ANY and locale => STRING shape, regardless of user config\n        mapper.enable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n        json = mapper.writeValueAsString(new DateAsDefaultBeanWithLocale(0L));\n        assertEquals(aposToQuotes(\"{'date':'1970-01-01T00:00:00.000+0000'}\"), json);\n        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n        json = mapper.writeValueAsString(new DateAsDefaultBeanWithLocale(0L));\n        assertEquals(aposToQuotes(\"{'date':'1970-01-01T00:00:00.000+0000'}\"), json);\n\n        // @JsonFormat with Shape.ANY and timezone => STRING shape, regardless of user config\n        mapper.enable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n        json = mapper.writeValueAsString(new DateAsDefaultBeanWithTimezone(0L));\n        assertEquals(aposToQuotes(\"{'date':'1970-01-01T01:00:00.000+0100'}\"), json);\n        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n        json = mapper.writeValueAsString(new DateAsDefaultBeanWithTimezone(0L));\n        assertEquals(aposToQuotes(\"{'date':'1970-01-01T01:00:00.000+0100'}\"), json);\n    }",
    "JacksonDatabind-46_testGenericSignature1195": "    public void testGenericSignature1195() throws Exception\n    {\n        TypeFactory tf = TypeFactory.defaultInstance();\n        Method m;\n        JavaType t;\n\n        m = Generic1195.class.getMethod(\"getList\");\n        t  = tf.constructType(m.getGenericReturnType());\n        assertEquals(\"Ljava/util/List<Ljava/lang/String;>;\", t.getGenericSignature());\n\n        m = Generic1195.class.getMethod(\"getMap\");\n        t  = tf.constructType(m.getGenericReturnType());\n        assertEquals(\"Ljava/util/Map<Ljava/lang/String;Ljava/lang/String;>;\",\n                t.getGenericSignature());\n\n        m = Generic1195.class.getMethod(\"getGeneric\");\n        t  = tf.constructType(m.getGenericReturnType());\n        assertEquals(\"Ljava/util/concurrent/atomic/AtomicReference<Ljava/lang/String;>;\", t.getGenericSignature());\n    }",
    "JacksonDatabind-47_testBrokenAnnotation": "    public void testBrokenAnnotation() throws Exception\n    {\n        try {\n            serializeAsString(MAPPER, new BrokenClass());\n        } catch (Exception e) {\n            verifyException(e, \"types not related\");\n        }\n    }",
    "JacksonDatabind-47_testSpecializedAsIntermediate": "    public void testSpecializedAsIntermediate() throws IOException {\n        assertEquals(aposToQuotes(\"{'value':{'a':1,'b':2}}\"),\n                WRITER.writeValueAsString(new Bean1178Holder()));\n    }",
    "JacksonDatabind-49_testIssue1255": "    public void testIssue1255() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        Foo mo = new Foo();\n        mo.bar1 = new Bar();\n        mo.bar2 = mo.bar1;\n\n        String json = mapper.writeValueAsString(mo);\n\n        Foo result = mapper.readValue(json, Foo.class);\n        assertNotNull(result);\n    }",
    "JacksonDatabind-51_testPolymorphicTypeViaCustom": "    public void testPolymorphicTypeViaCustom() throws Exception {\n        Base1270<Poly1> req = new Base1270<Poly1>();\n        Poly1 o = new Poly1();\n        o.val = \"optionValue\";\n        req.options = o;\n        req.val = \"some value\";\n        Top1270 top = new Top1270();\n        top.b = req;\n        String json = MAPPER.writeValueAsString(top);\n        JsonNode tree = MAPPER.readTree(json);\n        assertNotNull(tree.get(\"b\"));\n        assertNotNull(tree.get(\"b\").get(\"options\"));\n        assertNotNull(tree.get(\"b\").get(\"options\").get(\"val\"));\n\n        // Can we reverse the process? I have some doubts\n        Top1270 itemRead = MAPPER.readValue(json, Top1270.class);\n        assertNotNull(itemRead);\n        assertNotNull(itemRead.b);\n    }",
    "JacksonDatabind-54_testEmpty1256": "    public void testEmpty1256() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.setSerializationInclusion(JsonInclude.Include.NON_ABSENT);\n\n        String json = mapper.writeValueAsString(new Issue1256Bean());\n        assertEquals(\"{}\", json);\n    }",
    "JacksonDatabind-57_testRootBeans": "    public void testRootBeans() throws Exception\n    {\n        for (Source src : Source.values()) {\n            _testRootBeans(src);\n        }\n    }",
    "JacksonDatabind-58_testCauseOfThrowableIgnoral": "    public void testCauseOfThrowableIgnoral() throws Exception\n    {\n        final SecurityManager origSecMan = System.getSecurityManager();\n        try {\n            System.setSecurityManager(new CauseBlockingSecurityManager());\n            _testCauseOfThrowableIgnoral();\n        } finally {\n            System.setSecurityManager(origSecMan);\n        }\n    }",
    "JacksonDatabind-5_testDisappearingMixins515": "    public void testDisappearingMixins515() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.disable(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS)\n            .disable(MapperFeature.AUTO_DETECT_FIELDS)\n            .disable(MapperFeature.AUTO_DETECT_GETTERS)\n            .disable(MapperFeature.AUTO_DETECT_IS_GETTERS)\n            .disable(MapperFeature.INFER_PROPERTY_MUTATORS);\n        SimpleModule module = new SimpleModule(\"Test\");\n        module.setMixInAnnotation(Person.class, PersonMixin.class);        \n        mapper.registerModule(module);\n\n        assertEquals(\"{\\\"city\\\":\\\"Seattle\\\"}\", mapper.writeValueAsString(new PersonImpl()));\n    }",
    "JacksonDatabind-62_testUnmodifiable": "    public void testUnmodifiable() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        Class<?> unmodSetType = Collections.unmodifiableSet(Collections.<String>emptySet()).getClass();\n        mapper.addMixIn(unmodSetType, UnmodifiableSetMixin.class);\n        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);\n\n        final String EXPECTED_JSON = \"[\\\"\"+unmodSetType.getName()+\"\\\",[]]\";\n\n        Set<?> foo = mapper.readValue(EXPECTED_JSON, Set.class);\n        assertTrue(foo.isEmpty());\n    }",
    "JacksonDatabind-64_testIssue1351": "    public void testIssue1351() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.setSerializationInclusion(JsonInclude.Include.NON_DEFAULT);\n        assertEquals(aposToQuotes(\"{}\"),\n                mapper.writeValueAsString(new Issue1351Bean(null, (double) 0)));\n        // [databind#1417]\n        assertEquals(aposToQuotes(\"{}\"),\n                mapper.writeValueAsString(new Issue1351NonBean(0)));\n    }",
    "JacksonDatabind-67_testCustomEnumValueAndKeyViaModifier": "    public void testCustomEnumValueAndKeyViaModifier() throws IOException\n    {\n        SimpleModule module = new SimpleModule();\n        module.setDeserializerModifier(new BeanDeserializerModifier() {        \n            @Override\n            public JsonDeserializer<Enum> modifyEnumDeserializer(DeserializationConfig config,\n                    final JavaType type, BeanDescription beanDesc,\n                    final JsonDeserializer<?> deserializer) {\n                return new JsonDeserializer<Enum>() {\n                    @Override\n                    public Enum deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n                        Class<? extends Enum> rawClass = (Class<Enum<?>>) type.getRawClass();\n                        final String str = p.getValueAsString().toLowerCase();\n                        return KeyEnum.valueOf(rawClass, str);\n                    }\n                };\n            }\n\n            @Override\n            public KeyDeserializer modifyKeyDeserializer(DeserializationConfig config,\n                    final JavaType type, KeyDeserializer deserializer)\n            {\n                if (!type.isEnumType()) {\n                    return deserializer;\n                }\n                return new KeyDeserializer() {\n                    @Override\n                    public Object deserializeKey(String key, DeserializationContext ctxt)\n                            throws IOException\n                    {\n                        Class<? extends Enum> rawClass = (Class<Enum<?>>) type.getRawClass();\n                        return Enum.valueOf(rawClass, key.toLowerCase());\n                    }\n                };\n            }\n        });\n        ObjectMapper mapper = new ObjectMapper()\n                .registerModule(module);\n\n        // First, enum value as is\n        KeyEnum key = mapper.readValue(quote(KeyEnum.replacements.name().toUpperCase()),\n                KeyEnum.class);\n        assertSame(KeyEnum.replacements, key);\n\n        // and then as key\n        EnumMap<KeyEnum,String> map = mapper.readValue(\n                aposToQuotes(\"{'REPlaceMENTS':'foobar'}\"),\n                new TypeReference<EnumMap<KeyEnum,String>>() { });\n        assertEquals(1, map.size());\n        assertSame(KeyEnum.replacements, map.keySet().iterator().next());\n    }",
    "JacksonDatabind-6_testISO8601MissingSeconds": "    public void testISO8601MissingSeconds() throws Exception\n    {\n        String inputStr;\n        Date inputDate;\n        Calendar c = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n    \n        inputStr = \"1997-07-16T19:20+01:00\";\n        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);\n        c.setTime(inputDate);\n        assertEquals(1997, c.get(Calendar.YEAR));\n        assertEquals(Calendar.JULY, c.get(Calendar.MONTH));\n        assertEquals(16, c.get(Calendar.DAY_OF_MONTH));\n        assertEquals(19 - 1, c.get(Calendar.HOUR_OF_DAY));\n        assertEquals(0, c.get(Calendar.SECOND));\n        assertEquals(0, c.get(Calendar.MILLISECOND));\n}",
    "JacksonDatabind-6_testISO8601PartialMilliseconds": "    public void testISO8601PartialMilliseconds() throws Exception\n    {\n        String inputStr;\n        Date inputDate;\n        Calendar c = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n        \n        inputStr = \"2014-10-03T18:00:00.6-05:00\";\n        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);\n        c.setTime(inputDate);\n        assertEquals(2014, c.get(Calendar.YEAR));\n        assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));\n        assertEquals(3, c.get(Calendar.DAY_OF_MONTH));\n        assertEquals(600, c.get(Calendar.MILLISECOND));\n\n        inputStr = \"2014-10-03T18:00:00.61-05:00\";\n        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);\n        c.setTime(inputDate);\n        assertEquals(2014, c.get(Calendar.YEAR));\n        assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));\n        assertEquals(3, c.get(Calendar.DAY_OF_MONTH));\n        assertEquals(18 + 5, c.get(Calendar.HOUR_OF_DAY));\n        assertEquals(0, c.get(Calendar.MINUTE));\n        assertEquals(0, c.get(Calendar.SECOND));\n        assertEquals(610, c.get(Calendar.MILLISECOND));\n\n        inputStr = \"1997-07-16T19:20:30.45+01:00\";\n        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);\n        c.setTime(inputDate);\n        assertEquals(1997, c.get(Calendar.YEAR));\n        assertEquals(Calendar.JULY, c.get(Calendar.MONTH));\n        assertEquals(16, c.get(Calendar.DAY_OF_MONTH));\n        assertEquals(19 - 1, c.get(Calendar.HOUR_OF_DAY));\n        assertEquals(20, c.get(Calendar.MINUTE));\n        assertEquals(30, c.get(Calendar.SECOND));\n        assertEquals(450, c.get(Calendar.MILLISECOND));\n    }",
    "JacksonDatabind-70_testCaseInsensitiveUnwrap": "    public void testCaseInsensitiveUnwrap() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.enable(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES);\n        Person p = mapper.readValue(\"{ }\", Person.class);\n        assertNotNull(p);\n    }",
    "JacksonDatabind-71_testcharSequenceKeyMap": "    public void testcharSequenceKeyMap() throws Exception {\n        String JSON = aposToQuotes(\"{'a':'b'}\");\n        Map<CharSequence,String> result = MAPPER.readValue(JSON, new TypeReference<Map<CharSequence,String>>() { });\n        assertNotNull(result);\n        assertEquals(1, result.size());\n        assertEquals(\"b\", result.get(\"a\"));\n    }",
    "JacksonDatabind-74_testWithEmptyStringAsNullObject1533": "    public void testWithEmptyStringAsNullObject1533() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper().enable(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);\n        AsPropertyWrapper wrapper = mapper.readValue(\"{ \\\"value\\\": \\\"\\\" }\", AsPropertyWrapper.class);\n        assertNull(wrapper.value);\n    }",
    "JacksonDatabind-76_testWithUnwrappedAndCreatorMultipleParametersAtBeginning": "    public void testWithUnwrappedAndCreatorMultipleParametersAtBeginning() throws Exception {\n        final String json = aposToQuotes(\"{'animal_id':1234,'living':true,'first_name':'John','last_name':'Doe','years_old':30}\");\n\n        final ObjectMapper mapper = new ObjectMapper();\n        Animal animal = mapper.readValue(json, Animal.class);\n        assertEquals(1234, animal.getId());\n        assertNotNull(animal.getName());\n        assertEquals(\"John\", animal.getName().getFirst());\n        assertEquals(\"Doe\", animal.getName().getLast());\n        assertEquals(30, animal.getAge());\n        assertEquals(true, animal.isAlive());\n    }",
    "JacksonDatabind-76_testWithUnwrappedAndCreatorMultipleParametersInMiddle": "    public void testWithUnwrappedAndCreatorMultipleParametersInMiddle() throws Exception {\n        final String json = aposToQuotes(\"{'first_name':'John','animal_id':1234,'last_name':'Doe','living':true,'years_old':30}\");\n\n        final ObjectMapper mapper = new ObjectMapper();\n        Animal animal = mapper.readValue(json, Animal.class);\n        assertEquals(1234, animal.getId());\n        assertNotNull(animal.getName());\n        assertEquals(\"John\", animal.getName().getFirst());\n        assertEquals(\"Doe\", animal.getName().getLast());\n        assertEquals(30, animal.getAge());\n        assertEquals(true, animal.isAlive());\n    }",
    "JacksonDatabind-76_testWithUnwrappedAndCreatorSingleParameterAtBeginning": "    public void testWithUnwrappedAndCreatorSingleParameterAtBeginning() throws Exception {\n        final String json = aposToQuotes(\"{'person_id':1234,'first_name':'John','last_name':'Doe','years_old':30,'living':true}\");\n\n        final ObjectMapper mapper = new ObjectMapper();\n        Person person = mapper.readValue(json, Person.class);\n        assertEquals(1234, person.getId());\n        assertNotNull(person.getName());\n        assertEquals(\"John\", person.getName().getFirst());\n        assertEquals(\"Doe\", person.getName().getLast());\n        assertEquals(30, person.getAge());\n        assertEquals(true, person.isAlive());\n    }",
    "JacksonDatabind-76_testWithUnwrappedAndCreatorSingleParameterInMiddle": "    public void testWithUnwrappedAndCreatorSingleParameterInMiddle() throws Exception {\n        final String json = aposToQuotes(\"{'first_name':'John','last_name':'Doe','person_id':1234,'years_old':30,'living':true}\");\n\n        final ObjectMapper mapper = new ObjectMapper();\n        Person person = mapper.readValue(json, Person.class);\n        assertEquals(1234, person.getId());\n        assertNotNull(person.getName());\n        assertEquals(\"John\", person.getName().getFirst());\n        assertEquals(\"Doe\", person.getName().getLast());\n        assertEquals(30, person.getAge());\n        assertEquals(true, person.isAlive());\n    }",
    "JacksonDatabind-7_testDelegateWithTokenBuffer": "    public void testDelegateWithTokenBuffer() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        Value592 value = mapper.readValue(\"{\\\"a\\\":1,\\\"b\\\":2}\", Value592.class);\n        assertNotNull(value);\n        Object ob = value.stuff;\n        assertEquals(TokenBuffer.class, ob.getClass());\n        JsonParser jp = ((TokenBuffer) ob).asParser();\n        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n        assertEquals(\"a\", jp.getCurrentName());\n        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n        assertEquals(1, jp.getIntValue());\n        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n        assertEquals(\"b\", jp.getCurrentName());\n        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n        assertEquals(2, jp.getIntValue());\n        assertToken(JsonToken.END_OBJECT, jp.nextToken());\n        jp.close();\n    }",
    "JacksonDatabind-82_testIgnoreGetterNotSetter1595": "    public void testIgnoreGetterNotSetter1595() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        Simple1595 config = new Simple1595();\n        config.setId(123);\n        config.setName(\"jack\");\n        String json = mapper.writeValueAsString(config);\n        assertEquals(aposToQuotes(\"{'id':123}\"), json);\n        Simple1595 des = mapper.readValue(aposToQuotes(\"{'id':123,'name':'jack'}\"), Simple1595.class);\n        assertEquals(\"jack\", des.getName());\n    }",
    "JacksonDatabind-83_testWeirdStringHandling": "    public void testWeirdStringHandling() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper()\n            .addHandler(new WeirdStringHandler(SingleValuedEnum.A))\n            ;\n        SingleValuedEnum result = mapper.readValue(\"\\\"B\\\"\", SingleValuedEnum.class);\n        assertEquals(SingleValuedEnum.A, result);\n\n        // also, write [databind#1629] try this\n        mapper = new ObjectMapper()\n                .addHandler(new WeirdStringHandler(null));\n        UUID result2 = mapper.readValue(quote(\"not a uuid!\"), UUID.class);\n        assertNull(result2);\n    }",
    "JacksonDatabind-85_testFormatWithoutPattern": "    public void testFormatWithoutPattern() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.setDateFormat(new SimpleDateFormat(\"yyyy-MM-dd'X'HH:mm:ss\"));\n        String json = mapper.writeValueAsString(new DateAsDefaultBeanWithTimezone(0L));\n        assertEquals(aposToQuotes(\"{'date':'1970-01-01X01:00:00'}\"), json);\n    }",
    "JacksonDatabind-88_testNestedTypeCheck1735": "    public void testNestedTypeCheck1735() throws Exception\n    {\n        try {\n            MAPPER.readValue(aposToQuotes(\n\"{'w':{'type':'java.util.HashMap<java.lang.String,java.lang.String>'}}\"),\n                    Wrapper1735.class);\n            fail(\"Should not pass\");\n        } catch (JsonMappingException e) {\n            verifyException(e, \"not subtype of\");\n        }\n    }",
    "JacksonDatabind-8_testStringBuilder": "    public void testStringBuilder() throws Exception\n    {\n        StringBuilder sb = MAPPER.readValue(quote(\"abc\"), StringBuilder.class);\n        assertEquals(\"abc\", sb.toString());\n    }",
    "JacksonDatabind-91_testCachedSerialize": "    public void testCachedSerialize() throws IOException {\n        ObjectMapper mapper = new ObjectMapper();\n        String json = aposToQuotes(\"{'data':{'1st':'onedata','2nd':'twodata'}}\");\n\n        // Do deserialization with non-annotated map property\n        NonAnnotatedMapHolderClass ignored = mapper.readValue(json, NonAnnotatedMapHolderClass.class);\n        assertTrue(ignored.data.containsKey(\"1st\"));\n        assertTrue(ignored.data.containsKey(\"2nd\"));\n\n//mapper = new ObjectMapper();\n        \n        MapHolder model2 = mapper.readValue(json, MapHolder.class);\n        if (!model2.data.containsKey(\"1st (CUSTOM)\")\n            || !model2.data.containsKey(\"2nd (CUSTOM)\")) {\n            fail(\"Not using custom key deserializer for input: \"+json+\"; resulted in: \"+model2.data);\n        }\n    }",
    "JacksonDatabind-93_testJDKTypes1872": "    public void testJDKTypes1872() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);\n    \n        String json = aposToQuotes(String.format(\"{'@class':'%s','authorities':['java.util.ArrayList',[]]}\",\n                Authentication1872.class.getName()));\n        Authentication1872 result = mapper.readValue(json, Authentication1872.class);\n        assertNotNull(result);\n    }",
    "JacksonDatabind-96_testSnakeCaseWithOneArg": "    public void testSnakeCaseWithOneArg() throws Exception\n    {\n        final String MSG = \"1st\";\n        OneProperty actual = MAPPER.readValue(\n                \"{\\\"param_name0\\\":\\\"\"+MSG+\"\\\"}\",\n                OneProperty.class);\n        assertEquals(\"CTOR:\"+MSG, actual.paramName0);\n    }",
    "JacksonDatabind-97_testPOJONodeCustomSer": "    public void testPOJONodeCustomSer() throws Exception\n    {\n      Data data = new Data();\n      data.aStr = \"Hello\";\n\n      Map<String, Object> mapTest = new HashMap<>();\n      mapTest.put(\"data\", data);\n\n      ObjectNode treeTest = MAPPER.createObjectNode();\n      treeTest.putPOJO(\"data\", data);\n\n      final String EXP = \"{\\\"data\\\":{\\\"aStr\\\":\\\"The value is: Hello!\\\"}}\";\n      \n      String mapOut = MAPPER.writer().withAttribute(\"myAttr\", \"Hello!\").writeValueAsString(mapTest);\n      assertEquals(EXP, mapOut);\n\n      String treeOut = MAPPER.writer().withAttribute(\"myAttr\", \"Hello!\").writeValueAsString(treeTest);\n      assertEquals(EXP, treeOut);\n    }",
    "JacksonDatabind-98_testExample": "    public void testExample() throws Exception {\n        ObjectMapper mapper = new ObjectMapper();\n        \n        String json = mapper.writerWithDefaultPrettyPrinter()\n                .writeValueAsString(Arrays.asList(new AnimalAndType(AnimalType.Dog, new Dog())));\n        List<AnimalAndType> list = mapper.readerFor(new TypeReference<List<AnimalAndType>>() { })\n            .readValue(json);\n        assertNotNull(list);\n    }",
    "JacksonDatabind-99_testCanonicalNames": "    public void testCanonicalNames()\n    {\n        TypeFactory tf = TypeFactory.defaultInstance();\n        JavaType t = tf.constructType(java.util.Calendar.class);\n        String can = t.toCanonical();\n        assertEquals(\"java.util.Calendar\", can);\n        assertEquals(t, tf.constructFromCanonical(can));\n\n        // Generic maps and collections will default to Object.class if type-erased\n        t = tf.constructType(java.util.ArrayList.class);\n        can = t.toCanonical();\n        assertEquals(\"java.util.ArrayList<java.lang.Object>\", can);\n        assertEquals(t, tf.constructFromCanonical(can));\n\n        t = tf.constructType(java.util.TreeMap.class);\n        can = t.toCanonical();\n        assertEquals(\"java.util.TreeMap<java.lang.Object,java.lang.Object>\", can);\n        assertEquals(t, tf.constructFromCanonical(can));\n\n        // And then EnumMap (actual use case for us)\n        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);\n        can = t.toCanonical();\n        assertEquals(\"java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>\",\n                can);\n        assertEquals(t, tf.constructFromCanonical(can));\n\n        // [databind#2109]: also ReferenceTypes\n        t = tf.constructType(new TypeReference<AtomicReference<Long>>() { });\n        can = t.toCanonical();\n        assertEquals(\"java.util.concurrent.atomic.AtomicReference<java.lang.Long>\",\n                can);\n        assertEquals(t, tf.constructFromCanonical(can));\n\n        // [databind#1941]: allow \"raw\" types too\n        t = tf.constructFromCanonical(\"java.util.List\");\n        assertEquals(List.class, t.getRawClass());\n        assertEquals(CollectionType.class, t.getClass());\n        // 01-Mar-2018, tatu: not 100% should we expect type parameters here...\n        //    But currently we do NOT get any\n        /*\n        assertEquals(1, t.containedTypeCount());\n        assertEquals(Object.class, t.containedType(0).getRawClass());\n        */\n        assertEquals(Object.class, t.getContentType().getRawClass());\n        can = t.toCanonical();\n        assertEquals(\"java.util.List<java.lang.Object>\", can);\n        assertEquals(t, tf.constructFromCanonical(can));\n    }",
    "JacksonDatabind-9_testClassKey": "    public void testClassKey() throws IOException\n    {\n        Map<Class<?>,Integer> map = new LinkedHashMap<Class<?>,Integer>();\n        map.put(String.class, 2);\n        String json = MAPPER.writeValueAsString(map);\n        assertEquals(aposToQuotes(\"{'java.lang.String':2}\"), json);\n    }",
    "JacksonXml-1_testNestedUnwrappedLists180": "    public void testNestedUnwrappedLists180() throws Exception\n    {\n        /*\n        Records recs = new Records();\n        recs.records.add(new Record());\n        recs.records.add(new Record());\n        recs.records.add(new Record());\n        recs.records.get(0).fields.add(new Field(\"a\"));\n        recs.records.get(2).fields.add(new Field(\"b\"));\n\n        String xml = MAPPER.writerWithDefaultPrettyPrinter().writeValueAsString(recs);\n        */\n\n        String xml =\n\"<Records>\\n\"\n// Important: it's the empty CDATA here that causes breakage -- empty element alone would be fine\n//+\"<records>\\n</records>\\n\"\n+\"<records></records>\\n\"\n+\"  <records>\\n\"\n+\"   <fields name='b'/>\\n\"\n+\"  </records>\\n\"\n+\"</Records>\\n\"\n;\n        \n//System.out.println(\"XML: \"+xml);\n\n        Records result = MAPPER.readValue(xml, Records.class);\n        assertNotNull(result.records);\n        assertEquals(2, result.records.size());\n        assertNotNull(result.records.get(1));\n        assertEquals(1, result.records.get(1).fields.size());\n        assertEquals(\"b\", result.records.get(1).fields.get(0).name);\n\n        // also, first one ought not be null should it? Ideally not...\n        assertNotNull(result.records.get(0));\n    }",
    "JacksonXml-1_testNestedWithEmpty": "    public void testNestedWithEmpty() throws Exception\n    {\n        final String XML =\n\"<ServiceDelivery>\\n\"\n+\"  <ResponseTimestamp>2012-09-12T09:28:17.213-04:00</ResponseTimestamp>\\n\"\n+\"  <VehicleMonitoringDelivery>\\n\"\n+\"  </VehicleMonitoringDelivery>\\n\"\n+\"</ServiceDelivery>\\n\"\n                ;\n        \n        ServiceDelivery svc = _xmlMapper.readValue(XML, ServiceDelivery.class);\n        assertNotNull(svc);\n        assertNotNull(svc.vehicleMonitoringDelivery);\n        // 06-Jan-2015, tatu: Really should have one empty entry, not 0\n        assertEquals(1, svc.vehicleMonitoringDelivery.size());\n    }",
    "JacksonXml-1_testNestedWithEmpty2": "    public void testNestedWithEmpty2() throws Exception\n    {\n        final String XML =\n\"<ServiceDelivery>\\n\"\n+\"  <ResponseTimestamp>2012-09-12T09:28:17.213-04:00</ResponseTimestamp>\\n\"\n+\"  <VehicleMonitoringDelivery>\\n\"\n+\"    <VehicleActivity>\\n\"\n+\"    </VehicleActivity>\\n\"\n+\"  </VehicleMonitoringDelivery>\\n\"\n+\"</ServiceDelivery>\\n\"\n                ;\n        \n        ServiceDelivery svc = _xmlMapper.readValue(XML, ServiceDelivery.class);\n        assertNotNull(svc);\n        assertNotNull(svc.vehicleMonitoringDelivery);\n        assertEquals(1, svc.vehicleMonitoringDelivery.size());\n        VehicleMonitoringDelivery del = svc.vehicleMonitoringDelivery.get(0);\n        assertNotNull(del.vehicleActivity);\n        // 06-Jan-2015, tatu: Really should have one empty entry, not 0\n        assertEquals(1, del.vehicleActivity.size());\n    }",
    "JacksonXml-3_testXmlAttributesWithNextTextValue": "    public void testXmlAttributesWithNextTextValue() throws Exception\n    {\n        final String XML = \"<data max=\\\"7\\\" offset=\\\"9\\\"/>\";\n\n        FromXmlParser xp = (FromXmlParser) _xmlFactory.createParser(new StringReader(XML));\n\n        // First: verify handling without forcing array handling:\n        assertToken(JsonToken.START_OBJECT, xp.nextToken()); // <data>\n        assertToken(JsonToken.FIELD_NAME, xp.nextToken()); // <max>\n        assertEquals(\"max\", xp.getCurrentName());\n\n        assertEquals(\"7\", xp.nextTextValue());\n\n        assertToken(JsonToken.FIELD_NAME, xp.nextToken()); // <offset>\n        assertEquals(\"offset\", xp.getCurrentName());\n\n        assertEquals(\"offset\", xp.getText());\n\n        assertEquals(\"9\", xp.nextTextValue());\n\n        assertEquals(\"9\", xp.getText());\n\n        assertToken(JsonToken.END_OBJECT, xp.nextToken()); // </data>\n        xp.close();\n    }",
    "JacksonXml-4_testDynamicRootName": "    public void testDynamicRootName() throws IOException\n    {\n        String xml;\n\n        ObjectWriter w = _xmlMapper.writer().withRootName(\"rudy\");\n\n        xml = w.writeValueAsString(new StringBean(\"foo\"));\n        assertEquals(\"<rudy><text>foo</text></rudy>\", xml);\n\n        xml = w.writeValueAsString(new StringBean(null));\n        assertEquals(\"<rudy><text/></rudy>\", xml);\n\n        // and even with null will respect configured root name\n        xml = w.writeValueAsString(null);\n        assertEquals(\"<rudy/>\", xml);\n    }",
    "JacksonXml-5_testCopyWith": "    public void testCopyWith() throws Exception\n    {\n        XmlMapper xmlMapper = newMapper();\n        final ObjectMapper xmlMapperNoAnno = xmlMapper.copy()\n                .disable(MapperFeature.USE_ANNOTATIONS)\n                .disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);\n\n        String xml1 = xmlMapper.writeValueAsString(new Pojo282());\n        String xml2 = xmlMapperNoAnno.writeValueAsString(new Pojo282());\n\n        if (!xml1.contains(\"AnnotatedName\")) {\n            fail(\"Should use name 'AnnotatedName', xml = \"+xml1);\n        }\n        if (!xml2.contains(\"Pojo282\")\n                || xml2.contains(\"AnnotatedName\")) {\n            fail(\"Should NOT use name 'AnnotatedName' but 'Pojo282', xml = \"+xml1);\n        }\n    }",
    "Jsoup-10_absHandlesRelativeQuery": "    @Test public void absHandlesRelativeQuery() {\n        Document doc = Jsoup.parse(\"<a href='?foo'>One</a> <a href='bar.html?foo'>Two</a>\", \"http://jsoup.org/path/file?bar\");\n\n        Element a1 = doc.select(\"a\").first();\n        assertEquals(\"http://jsoup.org/path/file?foo\", a1.absUrl(\"href\"));\n\n        Element a2 = doc.select(\"a\").get(1);\n        assertEquals(\"http://jsoup.org/path/bar.html?foo\", a2.absUrl(\"href\"));\n    }",
    "Jsoup-13_absAttr": "    @Test public void absAttr() {\n        Document doc = Jsoup.parse(\"<a id=1 href='/foo'>One</a> <a id=2 href='http://jsoup.org'>Two</a>\");\n        Elements one = doc.select(\"#1\");\n        Elements two = doc.select(\"#2\");\n        Elements both = doc.select(\"a\");\n\n        assertEquals(\"\", one.attr(\"abs:href\"));\n        assertEquals(\"http://jsoup.org\", two.attr(\"abs:href\"));\n        assertEquals(\"http://jsoup.org\", both.attr(\"abs:href\"));\n    }",
    "Jsoup-13_handlesAbsPrefix": "    @Test public void handlesAbsPrefix() {\n        Document doc = Jsoup.parse(\"<a href=/foo>Hello</a>\", \"http://jsoup.org/\");\n        Element a = doc.select(\"a\").first();\n        assertEquals(\"/foo\", a.attr(\"href\"));\n        assertEquals(\"http://jsoup.org/foo\", a.attr(\"abs:href\"));\n        assertTrue(a.hasAttr(\"abs:href\"));\n    }",
    "Jsoup-13_handlesAbsPrefixOnHasAttr": "    @Test public void handlesAbsPrefixOnHasAttr() {\n        // 1: no abs url; 2: has abs url\n        Document doc = Jsoup.parse(\"<a id=1 href='/foo'>One</a> <a id=2 href='http://jsoup.org/'>Two</a>\");\n        Element one = doc.select(\"#1\").first();\n        Element two = doc.select(\"#2\").first();\n\n        assertFalse(one.hasAttr(\"abs:href\"));\n        assertTrue(one.hasAttr(\"href\"));\n        assertEquals(\"\", one.absUrl(\"href\"));\n\n        assertTrue(two.hasAttr(\"abs:href\"));\n        assertTrue(two.hasAttr(\"href\"));\n        assertEquals(\"http://jsoup.org/\", two.absUrl(\"href\"));\n    }",
    "Jsoup-13_hasAbsAttr": "    @Test public void hasAbsAttr() {\n        Document doc = Jsoup.parse(\"<a id=1 href='/foo'>One</a> <a id=2 href='http://jsoup.org'>Two</a>\");\n        Elements one = doc.select(\"#1\");\n        Elements two = doc.select(\"#2\");\n        Elements both = doc.select(\"a\");\n        assertFalse(one.hasAttr(\"abs:href\"));\n        assertTrue(two.hasAttr(\"abs:href\"));\n        assertTrue(both.hasAttr(\"abs:href\")); // hits on #2\n    }",
    "Jsoup-15_handlesDataOnlyTags": "    @Test public void handlesDataOnlyTags() {\n        String t = \"<style>font-family: bold</style>\";\n        List<Element> tels = Jsoup.parse(t).getElementsByTag(\"style\");\n        assertEquals(\"font-family: bold\", tels.get(0).data());\n        assertEquals(\"\", tels.get(0).text());\n\n        String s = \"<p>Hello</p><script>obj.insert('<a rel=\\\"none\\\" />');\\ni++;</script><p>There</p>\";\n        Document doc = Jsoup.parse(s);\n        assertEquals(\"Hello There\", doc.text());\n        assertEquals(\"obj.insert('<a rel=\\\"none\\\" />');\\ni++;\", doc.data());\n    }",
    "Jsoup-19_handlesCustomProtocols": "    @Test public void handlesCustomProtocols() {\n        String html = \"<img src='cid:12345' /> <img src='data:gzzt' />\";\n        String dropped = Jsoup.clean(html, Whitelist.basicWithImages());\n        assertEquals(\"<img /> \\n<img />\", dropped);\n\n        String preserved = Jsoup.clean(html, Whitelist.basicWithImages().addProtocols(\"img\", \"src\", \"cid\", \"data\"));\n        assertEquals(\"<img src=\\\"cid:12345\\\" /> \\n<img src=\\\"data:gzzt\\\" />\", preserved);\n    }",
    "Jsoup-1_createsStructureFromBodySnippet": "    @Test public void createsStructureFromBodySnippet() {\n        // the bar baz stuff naturally goes into the body, but the 'foo' goes into root, and the normalisation routine\n        // needs to move into the start of the body\n        String html = \"foo <b>bar</b> baz\";\n        Document doc = Jsoup.parse(html);\n        assertEquals (\"foo bar baz\", doc.text());\n\n    }",
    "Jsoup-20_discardsSpuriousByteOrderMark": "    @Test public void discardsSpuriousByteOrderMark() {\n        String html = \"\\uFEFF<html><head><title>One</title></head><body>Two</body></html>\";\n        ByteBuffer buffer = Charset.forName(\"UTF-8\").encode(html);\n        Document doc = DataUtil.parseByteData(buffer, \"UTF-8\", \"http://foo.com/\", Parser.htmlParser());\n        assertEquals(\"One\", doc.head().text());\n    }",
    "Jsoup-24_handlesQuotesInCommentsInScripts": "    @Test public void handlesQuotesInCommentsInScripts() {\n        String html = \"<script>\\n\" +\n                \"  <!--\\n\" +\n                \"    document.write('</scr' + 'ipt>');\\n\" +\n                \"  // -->\\n\" +\n                \"</script>\";\n        Document node = Jsoup.parseBodyFragment(html);\n        assertEquals(\"<script>\\n\" +\n                \"  <!--\\n\" +\n                \"    document.write('</scr' + 'ipt>');\\n\" +\n                \"  // -->\\n\" +\n                \"</script>\", node.body().html());\n    }",
    "Jsoup-26_handlesFramesets": "    @Test public void handlesFramesets() {\n        String dirty = \"<html><head><script></script><noscript></noscript></head><frameset><frame src=\\\"foo\\\" /><frame src=\\\"foo\\\" /></frameset></html>\";\n        String clean = Jsoup.clean(dirty, Whitelist.basic());\n        assertEquals(\"\", clean); // nothing good can come out of that\n\n        Document dirtyDoc = Jsoup.parse(dirty);\n        Document cleanDoc = new Cleaner(Whitelist.basic()).clean(dirtyDoc);\n        assertFalse(cleanDoc == null);\n        assertEquals(0, cleanDoc.body().childNodes().size());\n    }",
    "Jsoup-27_testCharset": "    public void testCharset() {\n        assertEquals(\"utf-8\", DataUtil.getCharsetFromContentType(\"text/html;charset=utf-8 \"));\n        assertEquals(\"UTF-8\", DataUtil.getCharsetFromContentType(\"text/html; charset=UTF-8\"));\n        assertEquals(\"ISO-8859-1\", DataUtil.getCharsetFromContentType(\"text/html; charset=ISO-8859-1\"));\n        assertEquals(null, DataUtil.getCharsetFromContentType(\"text/html\"));\n        assertEquals(null, DataUtil.getCharsetFromContentType(null));\n        assertEquals(null, DataUtil.getCharsetFromContentType(\"text/html;charset=Unknown\"));\n    }",
    "Jsoup-27_testQuotedCharset": "    @Test public void testQuotedCharset() {\n        assertEquals(\"utf-8\", DataUtil.getCharsetFromContentType(\"text/html; charset=\\\"utf-8\\\"\"));\n        assertEquals(\"UTF-8\", DataUtil.getCharsetFromContentType(\"text/html;charset=\\\"UTF-8\\\"\"));\n        assertEquals(\"ISO-8859-1\", DataUtil.getCharsetFromContentType(\"text/html; charset=\\\"ISO-8859-1\\\"\"));\n        assertEquals(null, DataUtil.getCharsetFromContentType(\"text/html; charset=\\\"Unsupported\\\"\"));\n    }",
    "Jsoup-2_handlesTextAfterData": "    @Test public void handlesTextAfterData() {\n        String h = \"<html><body>pre <script>inner</script> aft</body></html>\";\n        Document doc = Jsoup.parse(h);\n        assertEquals(\"<html><head></head><body>pre <script>inner</script> aft</body></html>\", TextUtil.stripNewlines(doc.html()));\n    }",
    "Jsoup-32_testClonesClassnames": "    @Test public void testClonesClassnames() {\n        Document doc = Jsoup.parse(\"<div class='one two'></div>\");\n        Element div = doc.select(\"div\").first();\n        Set<String> classes = div.classNames();\n        assertEquals(2, classes.size());\n        assertTrue(classes.contains(\"one\"));\n        assertTrue(classes.contains(\"two\"));\n\n        Element copy = div.clone();\n        Set<String> copyClasses = copy.classNames();\n        assertEquals(2, copyClasses.size());\n        assertTrue(copyClasses.contains(\"one\"));\n        assertTrue(copyClasses.contains(\"two\"));\n        copyClasses.add(\"three\");\n        copyClasses.remove(\"one\");\n\n        assertTrue(classes.contains(\"one\"));\n        assertFalse(classes.contains(\"three\"));\n        assertFalse(copyClasses.contains(\"one\"));\n        assertTrue(copyClasses.contains(\"three\"));\n\n        assertEquals(\"\", div.html());\n        assertEquals(\"\", copy.html());\n    }",
    "Jsoup-33_handlesKnownEmptyBlocks": "    @Test public void handlesKnownEmptyBlocks() {\n        // if a known tag, allow self closing outside of spec, but force an end tag. unknown tags can be self closing.\n        String h = \"<div id='1' /><script src='/foo' /><div id=2><img /><img></div><a id=3 /><i /><foo /><foo>One</foo> <hr /> hr text <hr> hr text two\";\n        Document doc = Jsoup.parse(h);\n        assertEquals(\"<div id=\\\"1\\\"></div><script src=\\\"/foo\\\"></script><div id=\\\"2\\\"><img /><img /></div><a id=\\\"3\\\"></a><i></i><foo /><foo>One</foo> <hr /> hr text <hr /> hr text two\", TextUtil.stripNewlines(doc.body().html()));\n    }",
    "Jsoup-34_handlesUnclosedCdataAtEOF": "    @Test public void handlesUnclosedCdataAtEOF() {\n        // https://github.com/jhy/jsoup/issues/349 would crash, as character reader would try to seek past EOF\n        String h = \"<![CDATA[]]\";\n        Document doc = Jsoup.parse(h);\n        assertEquals(1, doc.body().childNodeSize());\n    }",
    "Jsoup-34_nextIndexOfUnmatched": "    @Test public void nextIndexOfUnmatched() {\n        CharacterReader r = new CharacterReader(\"<[[one]]\");\n        assertEquals(-1, r.nextIndexOf(\"]]>\"));\n    }",
    "Jsoup-35_handlesUnclosedAnchors": "    @Test public void handlesUnclosedAnchors() {\n        String h = \"<a href='http://example.com/'>Link<p>Error link</a>\";\n        Document doc = Jsoup.parse(h);\n        String want = \"<a href=\\\"http://example.com/\\\">Link</a>\\n<p><a href=\\\"http://example.com/\\\">Error link</a></p>\";\n        assertEquals(want, doc.body().html());\n    }",
    "Jsoup-37_testNotPretty": "    @Test public void testNotPretty() {\n        Document doc = Jsoup.parse(\"<div>   \\n<p>Hello\\n there\\n</p></div>\");\n        doc.outputSettings().prettyPrint(false);\n        assertEquals(\"<html><head></head><body><div>   \\n<p>Hello\\n there\\n</p></div></body></html>\", doc.html());\n\n        Element div = doc.select(\"div\").first();\n        assertEquals(\"   \\n<p>Hello\\n there\\n</p>\", div.html());\n    }",
    "Jsoup-38_convertsImageToImg": "    @Test public void convertsImageToImg() {\n        // image to img, unless in a svg. old html cruft.\n        String h = \"<body><image><svg><image /></svg></body>\";\n        Document doc = Jsoup.parse(h);\n        assertEquals(\"<img />\\n<svg>\\n <image />\\n</svg>\", doc.body().html());\n    }",
    "Jsoup-39_discardsSpuriousByteOrderMarkWhenNoCharsetSet": "    @Test public void discardsSpuriousByteOrderMarkWhenNoCharsetSet() {\n        String html = \"\\uFEFF<html><head><title>One</title></head><body>Two</body></html>\";\n        ByteBuffer buffer = Charset.forName(\"UTF-8\").encode(html);\n        Document doc = DataUtil.parseByteData(buffer, null, \"http://foo.com/\", Parser.htmlParser());\n        assertEquals(\"One\", doc.head().text());\n        assertEquals(\"UTF-8\", doc.outputSettings().charset().displayName());\n    }",
    "Jsoup-40_constructorValidationOkWithBlankName": "    public void constructorValidationOkWithBlankName() {\n        DocumentType fail = new DocumentType(\"\",\"\", \"\", \"\");\n    }",
    "Jsoup-40_handlesInvalidDoctypes": "    @Test public void handlesInvalidDoctypes() {\n        // would previously throw invalid name exception on empty doctype\n        Document doc = Jsoup.parse(\"<!DOCTYPE>\");\n        assertEquals(\n                \"<!DOCTYPE> <html> <head></head> <body></body> </html>\",\n                StringUtil.normaliseWhitespace(doc.outerHtml()));\n\n        doc = Jsoup.parse(\"<!DOCTYPE><html><p>Foo</p></html>\");\n        assertEquals(\n                \"<!DOCTYPE> <html> <head></head> <body> <p>Foo</p> </body> </html>\",\n                StringUtil.normaliseWhitespace(doc.outerHtml()));\n\n        doc = Jsoup.parse(\"<!DOCTYPE \\u0000>\");\n        assertEquals(\n                \"<!DOCTYPE > <html> <head></head> <body></body> </html>\",\n                StringUtil.normaliseWhitespace(doc.outerHtml()));\n    }",
    "Jsoup-41_testHashAndEquals": "    public void testHashAndEquals() {\n        String doc1 = \"<div id=1><p class=one>One</p><p class=one>One</p><p class=one>Two</p><p class=two>One</p></div>\" +\n                \"<div id=2><p class=one>One</p><p class=one>One</p><p class=one>Two</p><p class=two>One</p></div>\";\n\n        Document doc = Jsoup.parse(doc1);\n        Elements els = doc.select(\"p\");\n\n        /*\n        for (Element el : els) {\n            System.out.println(el.hashCode() + \" - \" + el.outerHtml());\n        }\n\n        0 1534787905 - <p class=\"one\">One</p>\n        1 1534787905 - <p class=\"one\">One</p>\n        2 1539683239 - <p class=\"one\">Two</p>\n        3 1535455211 - <p class=\"two\">One</p>\n        4 1534787905 - <p class=\"one\">One</p>\n        5 1534787905 - <p class=\"one\">One</p>\n        6 1539683239 - <p class=\"one\">Two</p>\n        7 1535455211 - <p class=\"two\">One</p>\n        */\n        assertEquals(8, els.size());\n        Element e0 = els.get(0);\n        Element e1 = els.get(1);\n        Element e2 = els.get(2);\n        Element e3 = els.get(3);\n        Element e4 = els.get(4);\n        Element e5 = els.get(5);\n        Element e6 = els.get(6);\n        Element e7 = els.get(7);\n\n        assertEquals(e0, e1);\n        assertEquals(e0, e4);\n        assertEquals(e0, e5);\n        assertFalse(e0.equals(e2));\n        assertFalse(e0.equals(e3));\n        assertFalse(e0.equals(e6));\n        assertFalse(e0.equals(e7));\n\n        assertEquals(e0.hashCode(), e1.hashCode());\n        assertEquals(e0.hashCode(), e4.hashCode());\n        assertEquals(e0.hashCode(), e5.hashCode());\n        assertFalse(e0.hashCode() == (e2.hashCode()));\n        assertFalse(e0.hashCode() == (e3).hashCode());\n        assertFalse(e0.hashCode() == (e6).hashCode());\n        assertFalse(e0.hashCode() == (e7).hashCode());\n    }",
    "Jsoup-42_createsFormData": "    @Test public void createsFormData() {\n        String html = \"<form><input name='one' value='two'><select name='three'><option value='not'>\" +\n                \"<option value='four' selected><option value='five' selected><textarea name=six>seven</textarea>\" +\n                \"<input name='seven' type='radio' value='on' checked><input name='seven' type='radio' value='off'>\" +\n                \"<input name='eight' type='checkbox' checked><input name='nine' type='checkbox' value='unset'>\" +\n                \"<input name='ten' value='text' disabled>\" +\n                \"</form>\";\n        Document doc = Jsoup.parse(html);\n        FormElement form = (FormElement) doc.select(\"form\").first();\n        List<Connection.KeyVal> data = form.formData();\n\n        assertEquals(6, data.size());\n        assertEquals(\"one=two\", data.get(0).toString());\n        assertEquals(\"three=four\", data.get(1).toString());\n        assertEquals(\"three=five\", data.get(2).toString());\n        assertEquals(\"six=seven\", data.get(3).toString());\n        assertEquals(\"seven=on\", data.get(4).toString()); // set\n        assertEquals(\"eight=on\", data.get(5).toString()); // default\n        // nine should not appear, not checked checkbox\n        // ten should not appear, disabled\n    }",
    "Jsoup-42_usesOnForCheckboxValueIfNoValueSet": "    @Test public void usesOnForCheckboxValueIfNoValueSet() {\n        Document doc = Jsoup.parse(\"<form><input type=checkbox checked name=foo></form>\");\n        FormElement form = (FormElement) doc.select(\"form\").first();\n        List<Connection.KeyVal> data = form.formData();\n        assertEquals(\"on\", data.get(0).value());\n        assertEquals(\"foo\", data.get(0).key());\n    }",
    "Jsoup-43_testElementSiblingIndexSameContent": "    @Test public void testElementSiblingIndexSameContent() {\n        Document doc = Jsoup.parse(\"<div><p>One</p>...<p>One</p>...<p>One</p>\");\n        Elements ps = doc.select(\"p\");\n        assertTrue(0 == ps.get(0).elementSiblingIndex());\n        assertTrue(1 == ps.get(1).elementSiblingIndex());\n        assertTrue(2 == ps.get(2).elementSiblingIndex());\n    }",
    "Jsoup-43_testGetSiblingsWithDuplicateContent": "    @Test public void testGetSiblingsWithDuplicateContent() {\n        Document doc = Jsoup.parse(\"<div><p>Hello<p id=1>there<p>this<p>this<p>is<p>an<p id=last>element</div>\");\n        Element p = doc.getElementById(\"1\");\n        assertEquals(\"there\", p.text());\n        assertEquals(\"Hello\", p.previousElementSibling().text());\n        assertEquals(\"this\", p.nextElementSibling().text());\n        assertEquals(\"this\", p.nextElementSibling().nextElementSibling().text());\n        assertEquals(\"is\", p.nextElementSibling().nextElementSibling().nextElementSibling().text());\n        assertEquals(\"Hello\", p.firstElementSibling().text());\n        assertEquals(\"element\", p.lastElementSibling().text());\n    }",
    "Jsoup-45_testReinsertionModeForThCelss": "    @Test public void testReinsertionModeForThCelss() {\n        String body = \"<body> <table> <tr> <th> <table><tr><td></td></tr></table> <div> <table><tr><td></td></tr></table> </div> <div></div> <div></div> <div></div> </th> </tr> </table> </body>\";\n        Document doc = Jsoup.parse(body);\n        assertEquals(1, doc.body().children().size());\n    }",
    "Jsoup-46_testShiftJisRoundtrip": "    public void testShiftJisRoundtrip() throws Exception {\n        String input =\n                \"<html>\"\n                        +   \"<head>\"\n                        +     \"<meta http-equiv=\\\"content-type\\\" content=\\\"text/html; charset=Shift_JIS\\\" />\"\n                        +   \"</head>\"\n                        +   \"<body>\"\n                        +     \"before&nbsp;after\"\n                        +   \"</body>\"\n                        + \"</html>\";\n        InputStream is = new ByteArrayInputStream(input.getBytes(Charset.forName(\"ASCII\")));\n\n        Document doc = Jsoup.parse(is, null, \"http://example.com\");\n        doc.outputSettings().escapeMode(Entities.EscapeMode.xhtml);\n\n        String output = new String(doc.html().getBytes(doc.outputSettings().charset()), doc.outputSettings().charset());\n\n        assertFalse(\"Should not have contained a '?'.\", output.contains(\"?\"));\n        assertTrue(\"Should have contained a '&#xa0;' or a '&nbsp;'.\",\n                output.contains(\"&#xa0;\") || output.contains(\"&nbsp;\"));\n    }",
    "Jsoup-47_escapesGtInXmlAttributesButNotInHtml": "    @Test public void escapesGtInXmlAttributesButNotInHtml() {\n        // https://github.com/jhy/jsoup/issues/528 - < is OK in HTML attribute values, but not in XML\n\n\n        String docHtml = \"<a title='<p>One</p>'>One</a>\";\n        Document doc = Jsoup.parse(docHtml);\n        Element element = doc.select(\"a\").first();\n\n        doc.outputSettings().escapeMode(base);\n        assertEquals(\"<a title=\\\"<p>One</p>\\\">One</a>\", element.outerHtml());\n\n        doc.outputSettings().escapeMode(xhtml);\n        assertEquals(\"<a title=\\\"&lt;p>One&lt;/p>\\\">One</a>\", element.outerHtml());\n    }",
    "Jsoup-48_sameHeadersCombineWithComma": "    @Test public void sameHeadersCombineWithComma() {\n        Map<String, List<String>> headers = new HashMap<String, List<String>>();\n        List<String> values = new ArrayList<String>();\n        values.add(\"no-cache\");\n        values.add(\"no-store\");\n        headers.put(\"Cache-Control\", values);\n        HttpConnection.Response res = new HttpConnection.Response();\n        res.processResponseHeaders(headers);\n        assertEquals(\"no-cache, no-store\", res.header(\"Cache-Control\"));\n    }",
    "Jsoup-49_appendMustCorrectlyMoveChildrenInsideOneParentElement": "    public void appendMustCorrectlyMoveChildrenInsideOneParentElement() {\n        Document doc = new Document(\"\");\n        Element body = doc.appendElement(\"body\");\n        body.appendElement(\"div1\");\n        body.appendElement(\"div2\");\n        final Element div3 = body.appendElement(\"div3\");\n        div3.text(\"Check\");\n        final Element div4 = body.appendElement(\"div4\");\n\n        ArrayList<Element> toMove = new ArrayList<Element>();\n        toMove.add(div3);\n        toMove.add(div4);\n\n        body.insertChildren(0, toMove);\n\n        String result = doc.toString().replaceAll(\"\\\\s+\", \"\");\n        assertEquals(\"<body><div3>Check</div3><div4></div4><div1></div1><div2></div2></body>\", result);\n\n    }",
    "Jsoup-50_supportsBOMinFiles": "    public void supportsBOMinFiles() throws IOException {\n        // test files from http://www.i18nl10n.com/korean/utftest/\n        File in = getFile(\"/bomtests/bom_utf16be.html\");\n        Document doc = Jsoup.parse(in, null, \"http://example.com\");\n        assertTrue(doc.title().contains(\"UTF-16BE\"));\n        assertTrue(doc.text().contains(\"\"));\n\n        in = getFile(\"/bomtests/bom_utf16le.html\");\n        doc = Jsoup.parse(in, null, \"http://example.com\");\n        assertTrue(doc.title().contains(\"UTF-16LE\"));\n        assertTrue(doc.text().contains(\"\"));\n\n        in = getFile(\"/bomtests/bom_utf32be.html\");\n        doc = Jsoup.parse(in, null, \"http://example.com\");\n        assertTrue(doc.title().contains(\"UTF-32BE\"));\n        assertTrue(doc.text().contains(\"\"));\n\n        in = getFile(\"/bomtests/bom_utf32le.html\");\n        doc = Jsoup.parse(in, null, \"http://example.com\");\n        assertTrue(doc.title().contains(\"UTF-32LE\"));\n        assertTrue(doc.text().contains(\"\"));\n    }",
    "Jsoup-51_testSupportsNonAsciiTags": "    @Test public void testSupportsNonAsciiTags() {\n        String body = \"<>Yes</>\";\n        Document doc = Jsoup.parse(body);\n        Elements els = doc.select(\"\");\n        assertEquals(\"Yes\", els.text());\n    }",
    "Jsoup-53_attributeWithBrackets": "    @Test public void attributeWithBrackets() {\n        String html = \"<div data='End]'>One</div> <div data='[Another)]]'>Two</div>\";\n        Document doc = Jsoup.parse(html);\n        assertEquals(\"One\", doc.select(\"div[data='End]'\").first().text());\n        assertEquals(\"Two\", doc.select(\"div[data='[Another)]]'\").first().text());\n    }",
    "Jsoup-54_handlesInvalidAttributeNames": "    public void handlesInvalidAttributeNames() {\n        String html = \"<html><head></head><body style=\\\"color: red\\\" \\\" name\\\"></body></html>\";\n        org.jsoup.nodes.Document jsoupDoc;\n        jsoupDoc = Jsoup.parse(html);\n        Element body = jsoupDoc.select(\"body\").first();\n        assertTrue(body.hasAttr(\"\\\"\")); // actually an attribute with key '\"'. Correct per HTML5 spec, but w3c xml dom doesn't dig it\n        assertTrue(body.hasAttr(\"name\\\"\"));\n\n        Document w3Doc = new W3CDom().fromJsoup(jsoupDoc);\n    }",
    "Jsoup-55_dropsSlashFromAttributeName": "    @Test public void dropsSlashFromAttributeName() {\n        String html = \"<img /onerror='doMyJob'/>\";\n        Document doc = Jsoup.parse(html);\n        assertTrue(\"SelfClosingStartTag ignores last character\", doc.select(\"img[onerror]\").size() != 0);\n        assertEquals(\"<img onerror=\\\"doMyJob\\\">\", doc.body().html());\n\n        doc = Jsoup.parse(html, \"\", Parser.xmlParser());\n        assertEquals(\"<img onerror=\\\"doMyJob\\\" />\", doc.html());\n    }",
    "Jsoup-57_testChainedRemoveAttributes": "    public void testChainedRemoveAttributes() {\n        String html = \"<a one two three four>Text</a>\";\n        Document doc = Jsoup.parse(html);\n        Element a = doc.select(\"a\").first();\n        a\n            .removeAttr(\"zero\")\n            .removeAttr(\"one\")\n            .removeAttr(\"two\")\n            .removeAttr(\"three\")\n            .removeAttr(\"four\")\n            .removeAttr(\"five\");\n        assertEquals(\"<a>Text</a>\", a.outerHtml());\n    }",
    "Jsoup-59_handlesControlCharactersAfterTagName": "    @Test public void handlesControlCharactersAfterTagName() {\n        String html = \"<a/\\06>\";\n        String clean = Jsoup.clean(html, Whitelist.basic());\n        assertEquals(\"<a rel=\\\"nofollow\\\"></a>\", clean);\n    }",
    "Jsoup-59_handlesControlCodeInAttributeName": "    @Test public void handlesControlCodeInAttributeName() {\n        Document doc = Jsoup.parse(\"<p><a \\06=foo>One</a><a/\\06=bar><a foo\\06=bar>Two</a></p>\");\n        assertEquals(\"<p><a>One</a><a></a><a foo=\\\"bar\\\">Two</a></p>\", doc.body().html());\n    }",
    "Jsoup-5_parsesQuiteRoughAttributes": "    @Test public void parsesQuiteRoughAttributes() {\n        String html = \"<p =a>One<a =a\";\n        Document doc = Jsoup.parse(html);\n        assertEquals(\"<p>One<a></a></p>\", doc.body().html());\n        \n        doc = Jsoup.parse(\"<p .....\");\n        assertEquals(\"<p></p>\", doc.body().html());\n        \n        doc = Jsoup.parse(\"<p .....<p!!\");\n        assertEquals(\"<p></p>\\n<p></p>\", doc.body().html());\n    }",
    "Jsoup-61_hasClassCaseInsensitive": "    @Test public void hasClassCaseInsensitive() {\n        Elements els = Jsoup.parse(\"<p Class=One>One <p class=Two>Two <p CLASS=THREE>THREE\").select(\"p\");\n        Element one = els.get(0);\n        Element two = els.get(1);\n        Element thr = els.get(2);\n\n        assertTrue(one.hasClass(\"One\"));\n        assertTrue(one.hasClass(\"ONE\"));\n\n        assertTrue(two.hasClass(\"TWO\"));\n        assertTrue(two.hasClass(\"Two\"));\n\n        assertTrue(thr.hasClass(\"ThreE\"));\n        assertTrue(thr.hasClass(\"three\"));\n    }",
    "Jsoup-61_testByClassCaseInsensitive": "    @Test public void testByClassCaseInsensitive() {\n        String html = \"<p Class=foo>One <p Class=Foo>Two <p class=FOO>Three <p class=farp>Four\";\n        Elements elsFromClass = Jsoup.parse(html).select(\"P.Foo\");\n        Elements elsFromAttr = Jsoup.parse(html).select(\"p[class=foo]\");\n\n        assertEquals(elsFromAttr.size(), elsFromClass.size());\n        assertEquals(3, elsFromClass.size());\n        assertEquals(\"Two\", elsFromClass.get(1).text());\n    }",
    "Jsoup-62_caseSensitiveParseTree": "    @Test public void caseSensitiveParseTree() {\n        String html = \"<r><X>A</X><y>B</y></r>\";\n        Parser parser = Parser.htmlParser();\n        parser.settings(ParseSettings.preserveCase);\n        Document doc = parser.parseInput(html, \"\");\n        assertEquals(\"<r> <X> A </X> <y> B </y> </r>\", StringUtil.normaliseWhitespace(doc.body().html()));\n\n    }",
    "Jsoup-64_handlesKnownEmptyNoFrames": "    @Test public void handlesKnownEmptyNoFrames() {\n        String h = \"<html><head><noframes /><meta name=foo></head><body>One</body></html>\";\n        Document doc = Jsoup.parse(h);\n        assertEquals(\"<html><head><noframes></noframes><meta name=\\\"foo\\\"></head><body>One</body></html>\", TextUtil.stripNewlines(doc.html()));\n    }",
    "Jsoup-64_handlesKnownEmptyStyle": "    @Test public void handlesKnownEmptyStyle() {\n        String h = \"<html><head><style /><meta name=foo></head><body>One</body></html>\";\n        Document doc = Jsoup.parse(h);\n        assertEquals(\"<html><head><style></style><meta name=\\\"foo\\\"></head><body>One</body></html>\", TextUtil.stripNewlines(doc.html()));\n    }",
    "Jsoup-68_testHandlesDeepSpans": "  @Test public void testHandlesDeepSpans() {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < 200; i++) {\n            sb.append(\"<span>\");\n        }\n\n        sb.append(\"<p>One</p>\");\n\n        Document doc = Jsoup.parse(sb.toString());\n        assertEquals(200, doc.select(\"span\").size());\n        assertEquals(1, doc.select(\"p\").size());\n  }",
    "Jsoup-6_quoteReplacements": "    @Test public void quoteReplacements() {\n        String escaped = \"&#92; &#36;\";\n        String unescaped = \"\\\\ $\";\n        \n        assertEquals(unescaped, Entities.unescape(escaped));\n    }",
    "Jsoup-6_testYahooArticle": "    public void testYahooArticle() throws IOException {\n        File in = getFile(\"/htmltests/yahoo-article-1.html\");\n        Document doc = Jsoup.parse(in, \"UTF-8\", \"http://news.yahoo.com/s/nm/20100831/bs_nm/us_gm_china\");\n        Element p = doc.select(\"p:contains(Volt will be sold in the United States\").first();\n        assertEquals(\"In July, GM said its electric Chevrolet Volt will be sold in the United States at $41,000 -- $8,000 more than its nearest competitor, the Nissan Leaf.\", p.text());\n    }",
    "Jsoup-70_testKeepsPreTextAtDepth": "    @Test public void testKeepsPreTextAtDepth() {\n        String h = \"<pre><code><span><b>code\\n\\ncode</b></span></code></pre>\";\n        Document doc = Jsoup.parse(h);\n        assertEquals(\"code\\n\\ncode\", doc.text());\n        assertEquals(\"<pre><code><span><b>code\\n\\ncode</b></span></code></pre>\", doc.body().html());\n    }",
    "Jsoup-72_commentAtEnd": "  @Test public void commentAtEnd() throws Exception {\n      Document doc = Jsoup.parse(\"<!\");\n      assertTrue(doc.childNode(0) instanceof Comment);\n  }",
    "Jsoup-72_consumeToNonexistentEndWhenAtAnd": "    public void consumeToNonexistentEndWhenAtAnd() {\n        CharacterReader r = new CharacterReader(\"<!\");\n        assertTrue(r.matchConsume(\"<!\"));\n        assertTrue(r.isEmpty());\n\n        String after = r.consumeTo('>');\n        assertEquals(\"\", after);\n\n        assertTrue(r.isEmpty());\n    }",
    "Jsoup-75_booleanAttributeOutput": "    public void booleanAttributeOutput() {\n        Document doc = Jsoup.parse(\"<img src=foo noshade='' nohref async=async autofocus=false>\");\n        Element img = doc.selectFirst(\"img\");\n\n        assertEquals(\"<img src=\\\"foo\\\" noshade nohref async autofocus=\\\"false\\\">\", img.outerHtml());\n    }",
    "Jsoup-76_preSkipsFirstNewline": "  @Test public void preSkipsFirstNewline() {\n        Document doc = Jsoup.parse(\"<pre>\\n\\nOne\\nTwo\\n</pre>\");\n        Element pre = doc.selectFirst(\"pre\");\n        assertEquals(\"One\\nTwo\", pre.text());\n        assertEquals(\"\\nOne\\nTwo\\n\", pre.wholeText());\n  }",
    "Jsoup-77_normalizesDiscordantTags": "    @Test public void normalizesDiscordantTags() {\n        Parser parser = Parser.xmlParser().settings(ParseSettings.htmlDefault);\n        Document document = Jsoup.parse(\"<div>test</DIV><p></p>\", \"\", parser);\n        assertEquals(\"<div>\\n test\\n</div>\\n<p></p>\", document.html());\n        // was failing -> toString() = \"<div>\\n test\\n <p></p>\\n</div>\"\n    }",
    "Jsoup-80_handlesDodgyXmlDecl": "    public void handlesDodgyXmlDecl() {\n        String xml = \"<?xml version='1.0'><val>One</val>\";\n        Document doc = Jsoup.parse(xml, \"\", Parser.xmlParser());\n        assertEquals(\"One\", doc.select(\"val\").text());\n    }",
    "Jsoup-82_fallbackToUtfIfCantEncode": "    @Test public void fallbackToUtfIfCantEncode() throws IOException {\n        // that charset can't be encoded, so make sure we flip to utf\n\n        String in = \"<html><meta charset=\\\"ISO-2022-CN\\\"/>One</html>\";\n        Document doc = Jsoup.parse(new ByteArrayInputStream(in.getBytes()), null, \"\");\n\n        assertEquals(\"UTF-8\", doc.charset().name());\n        assertEquals(\"One\", doc.text());\n\n        String html = doc.outerHtml();\n        assertEquals(\"<html><head><meta charset=\\\"UTF-8\\\"></head><body>One</body></html>\", TextUtil.stripNewlines(html));\n    }",
    "Jsoup-84_treatsUndeclaredNamespaceAsLocalName": "    @Test public void treatsUndeclaredNamespaceAsLocalName() {\n        String html = \"<fb:like>One</fb:like>\";\n        org.jsoup.nodes.Document doc = Jsoup.parse(html);\n\n        Document w3Doc = new W3CDom().fromJsoup(doc);\n        Node htmlEl = w3Doc.getFirstChild();\n\n        assertNull(htmlEl.getNamespaceURI());\n        assertEquals(\"html\", htmlEl.getLocalName());\n        assertEquals(\"html\", htmlEl.getNodeName());\n\n        Node fb = htmlEl.getFirstChild().getNextSibling().getFirstChild();\n        assertNull(fb.getNamespaceURI());\n        assertEquals(\"like\", fb.getLocalName());\n        assertEquals(\"fb:like\", fb.getNodeName());\n\n    }",
    "Jsoup-85_validatesKeysNotEmpty": "    @Test(expected = IllegalArgumentException.class) public void validatesKeysNotEmpty() {\n        Attribute attr = new Attribute(\" \", \"Check\");\n    }",
    "Jsoup-86_handlesLTinScript": "    public void handlesLTinScript() {\n        // https://github.com/jhy/jsoup/issues/1139\n        String html = \"<script> var a=\\\"<?\\\"; var b=\\\"?>\\\"; </script>\";\n        Document doc = Jsoup.parse(html, \"\", Parser.xmlParser());\n        assertEquals(\"<script> var a=\\\"\\n <!--?\\\"; var b=\\\"?-->\\\"; </script>\", doc.html()); // converted from pseudo xmldecl to comment\n    }",
    "Jsoup-88_booleanAttributesAreEmptyStringValues": "    @Test public void booleanAttributesAreEmptyStringValues() {\n        Document doc = Jsoup.parse(\"<div hidden>\");\n        Attributes attributes = doc.body().child(0).attributes();\n        assertEquals(\"\", attributes.get(\"hidden\"));\n\n        Attribute first = attributes.iterator().next();\n        assertEquals(\"hidden\", first.getKey());\n        assertEquals(\"\", first.getValue());\n    }",
    "Jsoup-89_settersOnOrphanAttribute": "    @Test public void settersOnOrphanAttribute() {\n        Attribute attr = new Attribute(\"one\", \"two\");\n        attr.setKey(\"three\");\n        String oldVal = attr.setValue(\"four\");\n        assertEquals(\"two\", oldVal);\n        assertEquals(\"three\", attr.getKey());\n        assertEquals(\"four\", attr.getValue());\n        assertEquals(null, attr.parent);\n    }",
    "Jsoup-90_handlesHeaderEncodingOnRequest": "    @Test public void handlesHeaderEncodingOnRequest() {\n        Connection.Request req = new HttpConnection.Request();\n        req.addHeader(\"xxx\", \"\");\n    }",
    "Jsoup-93_createsFormData": "    @Test public void createsFormData() {\n        String html = \"<form><input name='one' value='two'><select name='three'><option value='not'>\" +\n                \"<option value='four' selected><option value='five' selected><textarea name=six>seven</textarea>\" +\n                \"<input name='seven' type='radio' value='on' checked><input name='seven' type='radio' value='off'>\" +\n                \"<input name='eight' type='checkbox' checked><input name='nine' type='checkbox' value='unset'>\" +\n                \"<input name='ten' value='text' disabled>\" +\n                \"<input name='eleven' value='text' type='button'>\" +\n                \"</form>\";\n        Document doc = Jsoup.parse(html);\n        FormElement form = (FormElement) doc.select(\"form\").first();\n        List<Connection.KeyVal> data = form.formData();\n\n        assertEquals(6, data.size());\n        assertEquals(\"one=two\", data.get(0).toString());\n        assertEquals(\"three=four\", data.get(1).toString());\n        assertEquals(\"three=five\", data.get(2).toString());\n        assertEquals(\"six=seven\", data.get(3).toString());\n        assertEquals(\"seven=on\", data.get(4).toString()); // set\n        assertEquals(\"eight=on\", data.get(5).toString()); // default\n        // nine should not appear, not checked checkbox\n        // ten should not appear, disabled\n        // eleven should not appear, button\n    }",
    "JxPath-10_testEmptyNodeSetOperations": "    public void testEmptyNodeSetOperations() {\n        assertXPathValue(context, \"/idonotexist = 0\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"/idonotexist != 0\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"/idonotexist < 0\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"/idonotexist > 0\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"/idonotexist >= 0\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"/idonotexist <= 0\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$array[position() < 1] = 0\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$array[position() < 1] != 0\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$array[position() < 1] < 0\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$array[position() < 1] > 0\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$array[position() < 1] >= 0\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$array[position() < 1] <= 0\", Boolean.FALSE, Boolean.class);\n    }",
    "JxPath-12_testElementDOM": "    public void testElementDOM() {\n        doTestElement(DocumentContainer.MODEL_DOM);\n    }",
    "JxPath-21_testMapValueEquality": "    public void testMapValueEquality() {\n        assertXPathValue(context, \"map/b != map/a\", Boolean.TRUE);\n        assertXPathValue(context, \"map/a != map/b\", Boolean.TRUE);\n        assertXPathValue(context, \"map/a != map/c\", Boolean.FALSE);\n        assertXPathValue(context, \"map/a = map/b\", Boolean.FALSE);\n        assertXPathValue(context, \"map/a = map/c\", Boolean.TRUE);\n        assertXPathValue(context, \"not(map/a = map/b)\", Boolean.TRUE);\n        assertXPathValue(context, \"not(map/a = map/c)\", Boolean.FALSE);\n    }",
    "JxPath-21_testNull": "    public void testNull() {\n\n        assertXPathPointerLenient(context, \"$null\", \"$null\");\n\n        assertXPathPointerLenient(context, \"$null[3]\", \"$null[3]\");\n\n        assertXPathPointerLenient(\n            context,\n            \"$testnull/nothing\",\n            \"$testnull/nothing\");\n\n        assertXPathPointerLenient(\n            context,\n            \"$testnull/nothing[2]\",\n            \"$testnull/nothing[2]\");\n\n        assertXPathPointerLenient(context, \"beans[8]/int\", \"/beans[8]/int\");\n\n        assertXPathValueIterator(\n            context,\n            \"$testnull/nothing[1]\",\n            list(null));\n\n        JXPathContext ctx = JXPathContext.newContext(new TestNull());\n        assertXPathValue(ctx, \"nothing\", null);\n\n        assertXPathValue(ctx, \"child/nothing\", null);\n\n        assertXPathValue(ctx, \"array[2]\", null);\n\n        assertXPathValueLenient(ctx, \"nothing/something\", null);\n\n        assertXPathValueLenient(ctx, \"array[2]/something\", null);\n    }",
    "JxPath-22_testInnerEmptyNamespaceDOM": "    public void testInnerEmptyNamespaceDOM() {\n        doTest(\"b:foo/test\", DocumentContainer.MODEL_DOM, \"/b:foo[1]/test[1]\");\n    }",
    "JxPath-5_testUnionOfVariableAndNode": "    public void testUnionOfVariableAndNode() throws Exception {\n        Document doc = DocumentBuilderFactory.newInstance()\n                .newDocumentBuilder().parse(\n                        new InputSource(new StringReader(\n                                \"<MAIN><A/><A/></MAIN>\")));\n\n        JXPathContext context = JXPathContext.newContext(doc);\n        context.getVariables().declareVariable(\"var\", \"varValue\");\n        int sz = 0;\n        for (Iterator ptrs = context.iteratePointers(\"$var | /MAIN/A\"); ptrs.hasNext(); sz++) {\n            ptrs.next();\n        }\n        assertEquals(3, sz);\n    }",
    "JxPath-6_testIterateVariable": "    public void testIterateVariable() throws Exception {\n        assertXPathValueIterator(context, \"$d\", list(\"a\", \"b\"));\n        assertXPathValue(context, \"$d = 'a'\", Boolean.TRUE);\n        assertXPathValue(context, \"$d = 'b'\", Boolean.TRUE);\n    }",
    "JxPath-8_testNan": "    public void testNan() {\n        assertXPathValue(context, \"$nan > $nan\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$nan < $nan\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$nan = $nan\", Boolean.TRUE, Boolean.class);\n        assertXPathValue(context, \"$nan > 0\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$nan < 0\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$nan = 0\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$nan > 1\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$nan < 1\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$nan = 1\", Boolean.FALSE, Boolean.class);\n    }"
}